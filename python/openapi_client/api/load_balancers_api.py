"""
    Morpheus API

    Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.  # noqa: E501

    The version of the OpenAPI document: 6.2.1
    Contact: dev@morpheusdata.com
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from openapi_client.api_client import ApiClient, Endpoint as _Endpoint
from openapi_client.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from openapi_client.model.create_load_balancer200_response import CreateLoadBalancer200Response
from openapi_client.model.create_load_balancer_monitor200_response import CreateLoadBalancerMonitor200Response
from openapi_client.model.create_load_balancer_monitor200_response_all_of import CreateLoadBalancerMonitor200ResponseAllOf
from openapi_client.model.create_load_balancer_monitor_request import CreateLoadBalancerMonitorRequest
from openapi_client.model.create_load_balancer_pool200_response import CreateLoadBalancerPool200Response
from openapi_client.model.create_load_balancer_pool200_response_all_of import CreateLoadBalancerPool200ResponseAllOf
from openapi_client.model.create_load_balancer_pool_node200_response import CreateLoadBalancerPoolNode200Response
from openapi_client.model.create_load_balancer_pool_node200_response_all_of import CreateLoadBalancerPoolNode200ResponseAllOf
from openapi_client.model.create_load_balancer_pool_node_request import CreateLoadBalancerPoolNodeRequest
from openapi_client.model.create_load_balancer_pool_request import CreateLoadBalancerPoolRequest
from openapi_client.model.create_load_balancer_profile200_response import CreateLoadBalancerProfile200Response
from openapi_client.model.create_load_balancer_profile200_response_all_of import CreateLoadBalancerProfile200ResponseAllOf
from openapi_client.model.create_load_balancer_profile_request import CreateLoadBalancerProfileRequest
from openapi_client.model.create_load_balancer_request import CreateLoadBalancerRequest
from openapi_client.model.create_load_balancer_virtual_server200_response import CreateLoadBalancerVirtualServer200Response
from openapi_client.model.create_load_balancer_virtual_server_request import CreateLoadBalancerVirtualServerRequest
from openapi_client.model.default_error import DefaultError
from openapi_client.model.get_load_balancer_type200_response import GetLoadBalancerType200Response
from openapi_client.model.list_load_balancer_monitors200_response import ListLoadBalancerMonitors200Response
from openapi_client.model.list_load_balancer_pool_nodes200_response import ListLoadBalancerPoolNodes200Response
from openapi_client.model.list_load_balancer_pools200_response import ListLoadBalancerPools200Response
from openapi_client.model.list_load_balancer_profiles200_response import ListLoadBalancerProfiles200Response
from openapi_client.model.list_load_balancer_types200_response import ListLoadBalancerTypes200Response
from openapi_client.model.list_load_balancer_virtual_servers200_response import ListLoadBalancerVirtualServers200Response
from openapi_client.model.list_load_balancers200_response import ListLoadBalancers200Response
from openapi_client.model.model200_success import Model200Success
from openapi_client.model.refresh_load_balancer200_response import RefreshLoadBalancer200Response
from openapi_client.model.update_load_balancer_request import UpdateLoadBalancerRequest
from openapi_client.model.update_load_balancer_virtual_server_request import UpdateLoadBalancerVirtualServerRequest


class LoadBalancersApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.create_load_balancer_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancer200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers',
                'operation_id': 'create_load_balancer',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'create_load_balancer_request',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'create_load_balancer_request':
                        (CreateLoadBalancerRequest,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'create_load_balancer_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_load_balancer_monitor_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerMonitor200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/monitors',
                'operation_id': 'create_load_balancer_monitor',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'create_load_balancer_monitor_request',
                ],
                'required': [
                    'load_balancer_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'create_load_balancer_monitor_request':
                        (CreateLoadBalancerMonitorRequest,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'create_load_balancer_monitor_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_load_balancer_pool_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerPool200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/pools',
                'operation_id': 'create_load_balancer_pool',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'create_load_balancer_pool_request',
                ],
                'required': [
                    'load_balancer_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'create_load_balancer_pool_request':
                        (CreateLoadBalancerPoolRequest,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'create_load_balancer_pool_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_load_balancer_pool_node_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerPoolNode200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancer-pools/{loadBalancerPoolId}/nodes',
                'operation_id': 'create_load_balancer_pool_node',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_pool_id',
                    'create_load_balancer_pool_node_request',
                ],
                'required': [
                    'load_balancer_pool_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_pool_id':
                        (float,),
                    'create_load_balancer_pool_node_request':
                        (CreateLoadBalancerPoolNodeRequest,),
                },
                'attribute_map': {
                    'load_balancer_pool_id': 'loadBalancerPoolId',
                },
                'location_map': {
                    'load_balancer_pool_id': 'path',
                    'create_load_balancer_pool_node_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_load_balancer_profile_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerProfile200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/profiles',
                'operation_id': 'create_load_balancer_profile',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'create_load_balancer_profile_request',
                ],
                'required': [
                    'load_balancer_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'create_load_balancer_profile_request':
                        (CreateLoadBalancerProfileRequest,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'create_load_balancer_profile_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.create_load_balancer_virtual_server_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerVirtualServer200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/virtual-servers',
                'operation_id': 'create_load_balancer_virtual_server',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'create_load_balancer_virtual_server_request',
                ],
                'required': [
                    'load_balancer_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'create_load_balancer_virtual_server_request':
                        (CreateLoadBalancerVirtualServerRequest,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'create_load_balancer_virtual_server_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.delete_load_balancer_endpoint = _Endpoint(
            settings={
                'response_type': (Model200Success,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}',
                'operation_id': 'delete_load_balancer',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                ],
                'required': [
                    'load_balancer_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_load_balancer_monitor_endpoint = _Endpoint(
            settings={
                'response_type': (Model200Success,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/monitors/{id}',
                'operation_id': 'delete_load_balancer_monitor',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'id',
                ],
                'required': [
                    'load_balancer_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'id':
                        (int,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_load_balancer_pool_endpoint = _Endpoint(
            settings={
                'response_type': (Model200Success,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/pools/{id}',
                'operation_id': 'delete_load_balancer_pool',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'id',
                ],
                'required': [
                    'load_balancer_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'id':
                        (int,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_load_balancer_pool_node_endpoint = _Endpoint(
            settings={
                'response_type': (Model200Success,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancer-pools/{loadBalancerPoolId}/nodes/{id}',
                'operation_id': 'delete_load_balancer_pool_node',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_pool_id',
                    'id',
                ],
                'required': [
                    'load_balancer_pool_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_pool_id':
                        (float,),
                    'id':
                        (int,),
                },
                'attribute_map': {
                    'load_balancer_pool_id': 'loadBalancerPoolId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_pool_id': 'path',
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_load_balancer_profile_endpoint = _Endpoint(
            settings={
                'response_type': (Model200Success,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/profiles/{id}',
                'operation_id': 'delete_load_balancer_profile',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'id',
                ],
                'required': [
                    'load_balancer_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'id':
                        (int,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.delete_load_balancer_virtual_server_endpoint = _Endpoint(
            settings={
                'response_type': (Model200Success,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/virtual-servers/{id}',
                'operation_id': 'delete_load_balancer_virtual_server',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'id',
                ],
                'required': [
                    'load_balancer_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'id':
                        (int,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_load_balancer_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancer200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}',
                'operation_id': 'get_load_balancer',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                ],
                'required': [
                    'load_balancer_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_load_balancer_monitor_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerMonitor200ResponseAllOf,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/monitors/{id}',
                'operation_id': 'get_load_balancer_monitor',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'id',
                ],
                'required': [
                    'load_balancer_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'id':
                        (int,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_load_balancer_pool_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerPool200ResponseAllOf,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/pools/{id}',
                'operation_id': 'get_load_balancer_pool',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'id',
                ],
                'required': [
                    'load_balancer_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'id':
                        (int,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_load_balancer_pool_node_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerPoolNode200ResponseAllOf,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancer-pools/{loadBalancerPoolId}/nodes/{id}',
                'operation_id': 'get_load_balancer_pool_node',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_pool_id',
                    'id',
                ],
                'required': [
                    'load_balancer_pool_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_pool_id':
                        (float,),
                    'id':
                        (int,),
                },
                'attribute_map': {
                    'load_balancer_pool_id': 'loadBalancerPoolId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_pool_id': 'path',
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_load_balancer_profile_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerProfile200ResponseAllOf,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/profiles/{id}',
                'operation_id': 'get_load_balancer_profile',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'id',
                ],
                'required': [
                    'load_balancer_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'id':
                        (int,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_load_balancer_type_endpoint = _Endpoint(
            settings={
                'response_type': (GetLoadBalancerType200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancer-types/{id}',
                'operation_id': 'get_load_balancer_type',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'id',
                ],
                'required': [
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'id':
                        (int,),
                },
                'attribute_map': {
                    'id': 'id',
                },
                'location_map': {
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_load_balancer_virtual_server_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerVirtualServer200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/virtual-servers/{id}',
                'operation_id': 'get_load_balancer_virtual_server',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'id',
                ],
                'required': [
                    'load_balancer_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'id':
                        (int,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_load_balancer_monitors_endpoint = _Endpoint(
            settings={
                'response_type': (ListLoadBalancerMonitors200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/monitors',
                'operation_id': 'list_load_balancer_monitors',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'max',
                    'offset',
                    'sort',
                    'direction',
                    'name',
                    'phrase',
                ],
                'required': [
                    'load_balancer_id',
                ],
                'nullable': [
                ],
                'enum': [
                    'direction',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('direction',): {

                        "ASC": "asc",
                        "DESC": "desc"
                    },
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'max':
                        (int,),
                    'offset':
                        (int,),
                    'sort':
                        (str,),
                    'direction':
                        (str,),
                    'name':
                        (str,),
                    'phrase':
                        (str,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'max': 'max',
                    'offset': 'offset',
                    'sort': 'sort',
                    'direction': 'direction',
                    'name': 'name',
                    'phrase': 'phrase',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'max': 'query',
                    'offset': 'query',
                    'sort': 'query',
                    'direction': 'query',
                    'name': 'query',
                    'phrase': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_load_balancer_pool_nodes_endpoint = _Endpoint(
            settings={
                'response_type': (ListLoadBalancerPoolNodes200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancer-pools/{loadBalancerPoolId}/nodes',
                'operation_id': 'list_load_balancer_pool_nodes',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_pool_id',
                    'max',
                    'offset',
                    'sort',
                    'direction',
                    'phrase',
                ],
                'required': [
                    'load_balancer_pool_id',
                ],
                'nullable': [
                ],
                'enum': [
                    'direction',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('direction',): {

                        "ASC": "asc",
                        "DESC": "desc"
                    },
                },
                'openapi_types': {
                    'load_balancer_pool_id':
                        (float,),
                    'max':
                        (int,),
                    'offset':
                        (int,),
                    'sort':
                        (str,),
                    'direction':
                        (str,),
                    'phrase':
                        (str,),
                },
                'attribute_map': {
                    'load_balancer_pool_id': 'loadBalancerPoolId',
                    'max': 'max',
                    'offset': 'offset',
                    'sort': 'sort',
                    'direction': 'direction',
                    'phrase': 'phrase',
                },
                'location_map': {
                    'load_balancer_pool_id': 'path',
                    'max': 'query',
                    'offset': 'query',
                    'sort': 'query',
                    'direction': 'query',
                    'phrase': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_load_balancer_pools_endpoint = _Endpoint(
            settings={
                'response_type': (ListLoadBalancerPools200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/pools',
                'operation_id': 'list_load_balancer_pools',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'max',
                    'offset',
                    'sort',
                    'direction',
                    'name',
                    'phrase',
                ],
                'required': [
                    'load_balancer_id',
                ],
                'nullable': [
                ],
                'enum': [
                    'direction',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('direction',): {

                        "ASC": "asc",
                        "DESC": "desc"
                    },
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'max':
                        (int,),
                    'offset':
                        (int,),
                    'sort':
                        (str,),
                    'direction':
                        (str,),
                    'name':
                        (str,),
                    'phrase':
                        (str,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'max': 'max',
                    'offset': 'offset',
                    'sort': 'sort',
                    'direction': 'direction',
                    'name': 'name',
                    'phrase': 'phrase',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'max': 'query',
                    'offset': 'query',
                    'sort': 'query',
                    'direction': 'query',
                    'name': 'query',
                    'phrase': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_load_balancer_profiles_endpoint = _Endpoint(
            settings={
                'response_type': (ListLoadBalancerProfiles200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/profiles',
                'operation_id': 'list_load_balancer_profiles',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'max',
                    'offset',
                    'sort',
                    'direction',
                    'name',
                    'phrase',
                ],
                'required': [
                    'load_balancer_id',
                ],
                'nullable': [
                ],
                'enum': [
                    'direction',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('direction',): {

                        "ASC": "asc",
                        "DESC": "desc"
                    },
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'max':
                        (int,),
                    'offset':
                        (int,),
                    'sort':
                        (str,),
                    'direction':
                        (str,),
                    'name':
                        (str,),
                    'phrase':
                        (str,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'max': 'max',
                    'offset': 'offset',
                    'sort': 'sort',
                    'direction': 'direction',
                    'name': 'name',
                    'phrase': 'phrase',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'max': 'query',
                    'offset': 'query',
                    'sort': 'query',
                    'direction': 'query',
                    'name': 'query',
                    'phrase': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_load_balancer_types_endpoint = _Endpoint(
            settings={
                'response_type': (ListLoadBalancerTypes200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancer-types',
                'operation_id': 'list_load_balancer_types',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'max',
                    'offset',
                    'sort',
                    'direction',
                    'option_types',
                    'phrase',
                    'name',
                    'code',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'direction',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('direction',): {

                        "ASC": "asc",
                        "DESC": "desc"
                    },
                },
                'openapi_types': {
                    'max':
                        (int,),
                    'offset':
                        (int,),
                    'sort':
                        (str,),
                    'direction':
                        (str,),
                    'option_types':
                        (bool,),
                    'phrase':
                        (str,),
                    'name':
                        (str,),
                    'code':
                        (str,),
                },
                'attribute_map': {
                    'max': 'max',
                    'offset': 'offset',
                    'sort': 'sort',
                    'direction': 'direction',
                    'option_types': 'optionTypes',
                    'phrase': 'phrase',
                    'name': 'name',
                    'code': 'code',
                },
                'location_map': {
                    'max': 'query',
                    'offset': 'query',
                    'sort': 'query',
                    'direction': 'query',
                    'option_types': 'query',
                    'phrase': 'query',
                    'name': 'query',
                    'code': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_load_balancer_virtual_servers_endpoint = _Endpoint(
            settings={
                'response_type': (ListLoadBalancerVirtualServers200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/virtual-servers',
                'operation_id': 'list_load_balancer_virtual_servers',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'max',
                    'offset',
                    'sort',
                    'direction',
                    'phrase',
                    'vip_name',
                    'vip_address',
                    'vip_hostname',
                ],
                'required': [
                    'load_balancer_id',
                ],
                'nullable': [
                ],
                'enum': [
                    'direction',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('direction',): {

                        "ASC": "asc",
                        "DESC": "desc"
                    },
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'max':
                        (int,),
                    'offset':
                        (int,),
                    'sort':
                        (str,),
                    'direction':
                        (str,),
                    'phrase':
                        (str,),
                    'vip_name':
                        (str,),
                    'vip_address':
                        (str,),
                    'vip_hostname':
                        (str,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'max': 'max',
                    'offset': 'offset',
                    'sort': 'sort',
                    'direction': 'direction',
                    'phrase': 'phrase',
                    'vip_name': 'vipName',
                    'vip_address': 'vipAddress',
                    'vip_hostname': 'vipHostname',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'max': 'query',
                    'offset': 'query',
                    'sort': 'query',
                    'direction': 'query',
                    'phrase': 'query',
                    'vip_name': 'query',
                    'vip_address': 'query',
                    'vip_hostname': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.list_load_balancers_endpoint = _Endpoint(
            settings={
                'response_type': (ListLoadBalancers200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers',
                'operation_id': 'list_load_balancers',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'max',
                    'offset',
                    'sort',
                    'direction',
                    'name',
                    'phrase',
                ],
                'required': [],
                'nullable': [
                ],
                'enum': [
                    'direction',
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                    ('direction',): {

                        "ASC": "asc",
                        "DESC": "desc"
                    },
                },
                'openapi_types': {
                    'max':
                        (int,),
                    'offset':
                        (int,),
                    'sort':
                        (str,),
                    'direction':
                        (str,),
                    'name':
                        (str,),
                    'phrase':
                        (str,),
                },
                'attribute_map': {
                    'max': 'max',
                    'offset': 'offset',
                    'sort': 'sort',
                    'direction': 'direction',
                    'name': 'name',
                    'phrase': 'phrase',
                },
                'location_map': {
                    'max': 'query',
                    'offset': 'query',
                    'sort': 'query',
                    'direction': 'query',
                    'name': 'query',
                    'phrase': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.refresh_load_balancer_endpoint = _Endpoint(
            settings={
                'response_type': (RefreshLoadBalancer200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/refresh',
                'operation_id': 'refresh_load_balancer',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                ],
                'required': [
                    'load_balancer_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.update_load_balancer_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancer200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}',
                'operation_id': 'update_load_balancer',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'update_load_balancer_request',
                ],
                'required': [
                    'load_balancer_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'update_load_balancer_request':
                        (UpdateLoadBalancerRequest,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'update_load_balancer_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.update_load_balancer_monitor_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerMonitor200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/monitors/{id}',
                'operation_id': 'update_load_balancer_monitor',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'id',
                    'create_load_balancer_monitor_request',
                ],
                'required': [
                    'load_balancer_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'id':
                        (int,),
                    'create_load_balancer_monitor_request':
                        (CreateLoadBalancerMonitorRequest,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'id': 'path',
                    'create_load_balancer_monitor_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.update_load_balancer_pool_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerPool200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/pools/{id}',
                'operation_id': 'update_load_balancer_pool',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'id',
                    'create_load_balancer_pool_request',
                ],
                'required': [
                    'load_balancer_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'id':
                        (int,),
                    'create_load_balancer_pool_request':
                        (CreateLoadBalancerPoolRequest,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'id': 'path',
                    'create_load_balancer_pool_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.update_load_balancer_pool_node_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerPoolNode200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancer-pools/{loadBalancerPoolId}/nodes/{id}',
                'operation_id': 'update_load_balancer_pool_node',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_pool_id',
                    'id',
                    'create_load_balancer_pool_node_request',
                ],
                'required': [
                    'load_balancer_pool_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_pool_id':
                        (float,),
                    'id':
                        (int,),
                    'create_load_balancer_pool_node_request':
                        (CreateLoadBalancerPoolNodeRequest,),
                },
                'attribute_map': {
                    'load_balancer_pool_id': 'loadBalancerPoolId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_pool_id': 'path',
                    'id': 'path',
                    'create_load_balancer_pool_node_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.update_load_balancer_profile_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerProfile200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/profiles/{id}',
                'operation_id': 'update_load_balancer_profile',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'id',
                    'create_load_balancer_profile_request',
                ],
                'required': [
                    'load_balancer_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'id':
                        (int,),
                    'create_load_balancer_profile_request':
                        (CreateLoadBalancerProfileRequest,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'id': 'path',
                    'create_load_balancer_profile_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.update_load_balancer_virtual_server_endpoint = _Endpoint(
            settings={
                'response_type': (CreateLoadBalancerVirtualServer200Response,),
                'auth': [
                    'bearerAuth'
                ],
                'endpoint_path': '/api/load-balancers/{loadBalancerId}/virtual-servers/{id}',
                'operation_id': 'update_load_balancer_virtual_server',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'load_balancer_id',
                    'id',
                    'update_load_balancer_virtual_server_request',
                ],
                'required': [
                    'load_balancer_id',
                    'id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'load_balancer_id':
                        (float,),
                    'id':
                        (int,),
                    'update_load_balancer_virtual_server_request':
                        (UpdateLoadBalancerVirtualServerRequest,),
                },
                'attribute_map': {
                    'load_balancer_id': 'loadBalancerId',
                    'id': 'id',
                },
                'location_map': {
                    'load_balancer_id': 'path',
                    'id': 'path',
                    'update_load_balancer_virtual_server_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )

    def create_load_balancer(
        self,
        **kwargs
    ):
        """Create a Load Balancer  # noqa: E501

        Available for NSX load balancers only  Use this command to create a load balancer.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_load_balancer(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            create_load_balancer_request (CreateLoadBalancerRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancer200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        return self.create_load_balancer_endpoint.call_with_http_info(**kwargs)

    def create_load_balancer_monitor(
        self,
        load_balancer_id,
        **kwargs
    ):
        """Create a Load Balancer Monitor  # noqa: E501

        Use this command to create a load balancer Monitor.  This endpoint allows creating a Load Balancer Monitor. Configuration options vary by Load Balancer Type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_load_balancer_monitor(load_balancer_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID

        Keyword Args:
            create_load_balancer_monitor_request (CreateLoadBalancerMonitorRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerMonitor200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        return self.create_load_balancer_monitor_endpoint.call_with_http_info(**kwargs)

    def create_load_balancer_pool(
        self,
        load_balancer_id,
        **kwargs
    ):
        """Create a Load Balancer Pool  # noqa: E501

        Use this command to create a load balancer pool.  This endpoint allows creating a Load Balancer Pool. Configuration options vary by Load Balancer Type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_load_balancer_pool(load_balancer_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID

        Keyword Args:
            create_load_balancer_pool_request (CreateLoadBalancerPoolRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerPool200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        return self.create_load_balancer_pool_endpoint.call_with_http_info(**kwargs)

    def create_load_balancer_pool_node(
        self,
        load_balancer_pool_id,
        **kwargs
    ):
        """Create a Load Balancer Pool Node  # noqa: E501

        Use this command to create a load balancer pool node.  This endpoint allows creating a Load Balancer Pool Node. Configuration options vary by Load Balancer Type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_load_balancer_pool_node(load_balancer_pool_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_pool_id (float): Load Balancer Pool ID

        Keyword Args:
            create_load_balancer_pool_node_request (CreateLoadBalancerPoolNodeRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerPoolNode200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_pool_id'] = \
            load_balancer_pool_id
        return self.create_load_balancer_pool_node_endpoint.call_with_http_info(**kwargs)

    def create_load_balancer_profile(
        self,
        load_balancer_id,
        **kwargs
    ):
        """Create a Load Balancer Profile  # noqa: E501

        Use this command to create a load balancer Profile.  This endpoint allows creating a Load Balancer Profile. Configuration options vary by Load Balancer Type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_load_balancer_profile(load_balancer_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID

        Keyword Args:
            create_load_balancer_profile_request (CreateLoadBalancerProfileRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerProfile200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        return self.create_load_balancer_profile_endpoint.call_with_http_info(**kwargs)

    def create_load_balancer_virtual_server(
        self,
        load_balancer_id,
        **kwargs
    ):
        """Create a Load Balancer Virtual Server  # noqa: E501

        Use this command to create a load balancer virtual server.  This endpoint allows creating a Load Balancer Virtual Server. Configuration options vary by Load Balancer Type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_load_balancer_virtual_server(load_balancer_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID

        Keyword Args:
            create_load_balancer_virtual_server_request (CreateLoadBalancerVirtualServerRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerVirtualServer200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        return self.create_load_balancer_virtual_server_endpoint.call_with_http_info(**kwargs)

    def delete_load_balancer(
        self,
        load_balancer_id,
        **kwargs
    ):
        """Delete a Load Balancer  # noqa: E501

        Will delete a Load Balancer from the system and make it no longer usable.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_load_balancer(load_balancer_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            Model200Success
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        return self.delete_load_balancer_endpoint.call_with_http_info(**kwargs)

    def delete_load_balancer_monitor(
        self,
        load_balancer_id,
        id,
        **kwargs
    ):
        """Delete a Load Balancer Monitor  # noqa: E501

        Will delete a Load Balancer Monitor from the system and make it no longer usable.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_load_balancer_monitor(load_balancer_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            Model200Success
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        kwargs['id'] = \
            id
        return self.delete_load_balancer_monitor_endpoint.call_with_http_info(**kwargs)

    def delete_load_balancer_pool(
        self,
        load_balancer_id,
        id,
        **kwargs
    ):
        """Delete a Load Balancer Pool  # noqa: E501

        Will delete a Load Balancer Pool from the system and make it no longer usable.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_load_balancer_pool(load_balancer_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            Model200Success
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        kwargs['id'] = \
            id
        return self.delete_load_balancer_pool_endpoint.call_with_http_info(**kwargs)

    def delete_load_balancer_pool_node(
        self,
        load_balancer_pool_id,
        id,
        **kwargs
    ):
        """Delete a Load Balancer Pool Node  # noqa: E501

        Will delete a Load Balancer Pool Node from the system and make it no longer usable.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_load_balancer_pool_node(load_balancer_pool_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_pool_id (float): Load Balancer Pool ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            Model200Success
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_pool_id'] = \
            load_balancer_pool_id
        kwargs['id'] = \
            id
        return self.delete_load_balancer_pool_node_endpoint.call_with_http_info(**kwargs)

    def delete_load_balancer_profile(
        self,
        load_balancer_id,
        id,
        **kwargs
    ):
        """Delete a Load Balancer Profile  # noqa: E501

        Will delete a Load Balancer Profile from the system and make it no longer usable.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_load_balancer_profile(load_balancer_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            Model200Success
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        kwargs['id'] = \
            id
        return self.delete_load_balancer_profile_endpoint.call_with_http_info(**kwargs)

    def delete_load_balancer_virtual_server(
        self,
        load_balancer_id,
        id,
        **kwargs
    ):
        """Delete a Load Balancer Virtual Server  # noqa: E501

        Will delete a Load Balancer Virtual Server from the system and make it no longer usable.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_load_balancer_virtual_server(load_balancer_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            Model200Success
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        kwargs['id'] = \
            id
        return self.delete_load_balancer_virtual_server_endpoint.call_with_http_info(**kwargs)

    def get_load_balancer(
        self,
        load_balancer_id,
        **kwargs
    ):
        """Get a Specific Load Balancer  # noqa: E501

        This endpoint retrieves a specific Load Balancer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_load_balancer(load_balancer_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancer200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        return self.get_load_balancer_endpoint.call_with_http_info(**kwargs)

    def get_load_balancer_monitor(
        self,
        load_balancer_id,
        id,
        **kwargs
    ):
        """Get a Specific Load Balancer Monitor  # noqa: E501

        This endpoint retrieves a specific Load Balancer Monitor.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_load_balancer_monitor(load_balancer_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerMonitor200ResponseAllOf
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        kwargs['id'] = \
            id
        return self.get_load_balancer_monitor_endpoint.call_with_http_info(**kwargs)

    def get_load_balancer_pool(
        self,
        load_balancer_id,
        id,
        **kwargs
    ):
        """Get a Specific Load Balancer Pool  # noqa: E501

        This endpoint retrieves a specific Load Balancer Pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_load_balancer_pool(load_balancer_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerPool200ResponseAllOf
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        kwargs['id'] = \
            id
        return self.get_load_balancer_pool_endpoint.call_with_http_info(**kwargs)

    def get_load_balancer_pool_node(
        self,
        load_balancer_pool_id,
        id,
        **kwargs
    ):
        """Get a Specific Load Balancer Pool Node  # noqa: E501

        This endpoint retrieves a specific Load Balancer Pool Node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_load_balancer_pool_node(load_balancer_pool_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_pool_id (float): Load Balancer Pool ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerPoolNode200ResponseAllOf
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_pool_id'] = \
            load_balancer_pool_id
        kwargs['id'] = \
            id
        return self.get_load_balancer_pool_node_endpoint.call_with_http_info(**kwargs)

    def get_load_balancer_profile(
        self,
        load_balancer_id,
        id,
        **kwargs
    ):
        """Get a Specific Load Balancer Profile  # noqa: E501

        This endpoint retrieves a specific Load Balancer Profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_load_balancer_profile(load_balancer_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerProfile200ResponseAllOf
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        kwargs['id'] = \
            id
        return self.get_load_balancer_profile_endpoint.call_with_http_info(**kwargs)

    def get_load_balancer_type(
        self,
        id,
        **kwargs
    ):
        """Get a Specific Load Balancer Type  # noqa: E501

        This endpoint will retrieve a specific load balancer type by id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_load_balancer_type(id, async_req=True)
        >>> result = thread.get()

        Args:
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            GetLoadBalancerType200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['id'] = \
            id
        return self.get_load_balancer_type_endpoint.call_with_http_info(**kwargs)

    def get_load_balancer_virtual_server(
        self,
        load_balancer_id,
        id,
        **kwargs
    ):
        """Get a Specific Load Balancer Virtual Server  # noqa: E501

        This endpoint retrieves a specific Load Balancer Virtual Server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_load_balancer_virtual_server(load_balancer_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerVirtualServer200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        kwargs['id'] = \
            id
        return self.get_load_balancer_virtual_server_endpoint.call_with_http_info(**kwargs)

    def list_load_balancer_monitors(
        self,
        load_balancer_id,
        **kwargs
    ):
        """Get All Load Balancer Monitors For Load Balancer  # noqa: E501

        This endpoint retrieves all load balancer monitors associated with a specified load balancer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_load_balancer_monitors(load_balancer_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID

        Keyword Args:
            max (int): Maximum number of records to return, -1 can be used to fetch all records. [optional] if omitted the server will use the default value of 25
            offset (int): Offset records, the number of records to skip, for paginating requests. [optional] if omitted the server will use the default value of 0
            sort (str): Sort order, the name of the property to sort by. [optional] if omitted the server will use the default value of "name"
            direction (str): Sort direction, use 'desc' to reverse sort. [optional] if omitted the server will use the default value of "asc"
            name (str): Filter by name, wildcard may be specified as %, eg. example-%. [optional]
            phrase (str): Search phrase for partial matches on name or description. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ListLoadBalancerMonitors200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        return self.list_load_balancer_monitors_endpoint.call_with_http_info(**kwargs)

    def list_load_balancer_pool_nodes(
        self,
        load_balancer_pool_id,
        **kwargs
    ):
        """Get All Load Balancer Pool Nodes For Load Balancer Pool  # noqa: E501

        This endpoint retrieves all load balancer pool nodes associated with a specified load balancer pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_load_balancer_pool_nodes(load_balancer_pool_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_pool_id (float): Load Balancer Pool ID

        Keyword Args:
            max (int): Maximum number of records to return, -1 can be used to fetch all records. [optional] if omitted the server will use the default value of 25
            offset (int): Offset records, the number of records to skip, for paginating requests. [optional] if omitted the server will use the default value of 0
            sort (str): Sort order, the name of the property to sort by. [optional] if omitted the server will use the default value of "name"
            direction (str): Sort direction, use 'desc' to reverse sort. [optional] if omitted the server will use the default value of "asc"
            phrase (str): Search phrase for partial matches on name or description. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ListLoadBalancerPoolNodes200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_pool_id'] = \
            load_balancer_pool_id
        return self.list_load_balancer_pool_nodes_endpoint.call_with_http_info(**kwargs)

    def list_load_balancer_pools(
        self,
        load_balancer_id,
        **kwargs
    ):
        """Get All Load Balancer Pools For Load Balancer  # noqa: E501

        This endpoint retrieves all load balancer pools associated with a specified load balancer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_load_balancer_pools(load_balancer_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID

        Keyword Args:
            max (int): Maximum number of records to return, -1 can be used to fetch all records. [optional] if omitted the server will use the default value of 25
            offset (int): Offset records, the number of records to skip, for paginating requests. [optional] if omitted the server will use the default value of 0
            sort (str): Sort order, the name of the property to sort by. [optional] if omitted the server will use the default value of "name"
            direction (str): Sort direction, use 'desc' to reverse sort. [optional] if omitted the server will use the default value of "asc"
            name (str): Filter by name, wildcard may be specified as %, eg. example-%. [optional]
            phrase (str): Search phrase for partial matches on name or description. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ListLoadBalancerPools200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        return self.list_load_balancer_pools_endpoint.call_with_http_info(**kwargs)

    def list_load_balancer_profiles(
        self,
        load_balancer_id,
        **kwargs
    ):
        """Get All Load Balancer Profiles For Load Balancer  # noqa: E501

        This endpoint retrieves all load balancer profiles associated with a specified load balancer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_load_balancer_profiles(load_balancer_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID

        Keyword Args:
            max (int): Maximum number of records to return, -1 can be used to fetch all records. [optional] if omitted the server will use the default value of 25
            offset (int): Offset records, the number of records to skip, for paginating requests. [optional] if omitted the server will use the default value of 0
            sort (str): Sort order, the name of the property to sort by. [optional] if omitted the server will use the default value of "name"
            direction (str): Sort direction, use 'desc' to reverse sort. [optional] if omitted the server will use the default value of "asc"
            name (str): Filter by name, wildcard may be specified as %, eg. example-%. [optional]
            phrase (str): Search phrase for partial matches on name or description. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ListLoadBalancerProfiles200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        return self.list_load_balancer_profiles_endpoint.call_with_http_info(**kwargs)

    def list_load_balancer_types(
        self,
        **kwargs
    ):
        """Get All Load Balancer Types  # noqa: E501

        This endpoint retrieves all Load Balancer Types.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_load_balancer_types(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            max (int): Maximum number of records to return, -1 can be used to fetch all records. [optional] if omitted the server will use the default value of 25
            offset (int): Offset records, the number of records to skip, for paginating requests. [optional] if omitted the server will use the default value of 0
            sort (str): Sort order, the name of the property to sort by. [optional] if omitted the server will use the default value of "name"
            direction (str): Sort direction, use 'desc' to reverse sort. [optional] if omitted the server will use the default value of "asc"
            option_types (bool): Pass true to include optionTypes in the response for each entry.. [optional] if omitted the server will use the default value of False
            phrase (str): Search phrase for partial matches on name or description. [optional]
            name (str): Filter by name, wildcard may be specified as %, eg. example-%. [optional]
            code (str): If specified will return an exact match on code. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ListLoadBalancerTypes200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        return self.list_load_balancer_types_endpoint.call_with_http_info(**kwargs)

    def list_load_balancer_virtual_servers(
        self,
        load_balancer_id,
        **kwargs
    ):
        """Get All Load Balancer Virtual Servers For Load Balancer  # noqa: E501

        This endpoint retrieves load balancer virtual servers associated with a specified load balancer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_load_balancer_virtual_servers(load_balancer_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID

        Keyword Args:
            max (int): Maximum number of records to return, -1 can be used to fetch all records. [optional] if omitted the server will use the default value of 25
            offset (int): Offset records, the number of records to skip, for paginating requests. [optional] if omitted the server will use the default value of 0
            sort (str): Sort order, the name of the property to sort by. [optional] if omitted the server will use the default value of "name"
            direction (str): Sort direction, use 'desc' to reverse sort. [optional] if omitted the server will use the default value of "asc"
            phrase (str): Search phrase for partial matches on name or description. [optional]
            vip_name (str): If specified will return an exact match on vipName. [optional]
            vip_address (str): If specified will return an exact match on vipAddress. [optional]
            vip_hostname (str): If specified will return an exact match on vipHostname. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ListLoadBalancerVirtualServers200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        return self.list_load_balancer_virtual_servers_endpoint.call_with_http_info(**kwargs)

    def list_load_balancers(
        self,
        **kwargs
    ):
        """Get All Load Balancers  # noqa: E501

        This endpoint retrieves all load balancers associated with the account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_load_balancers(async_req=True)
        >>> result = thread.get()


        Keyword Args:
            max (int): Maximum number of records to return, -1 can be used to fetch all records. [optional] if omitted the server will use the default value of 25
            offset (int): Offset records, the number of records to skip, for paginating requests. [optional] if omitted the server will use the default value of 0
            sort (str): Sort order, the name of the property to sort by. [optional] if omitted the server will use the default value of "name"
            direction (str): Sort direction, use 'desc' to reverse sort. [optional] if omitted the server will use the default value of "asc"
            name (str): Filter by name, wildcard may be specified as %, eg. example-%. [optional]
            phrase (str): Search phrase for partial matches on name or description. [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            ListLoadBalancers200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        return self.list_load_balancers_endpoint.call_with_http_info(**kwargs)

    def refresh_load_balancer(
        self,
        load_balancer_id,
        **kwargs
    ):
        """Refresh a Load Balancer  # noqa: E501

        Will refresh a Load Balancer.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.refresh_load_balancer(load_balancer_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            RefreshLoadBalancer200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        return self.refresh_load_balancer_endpoint.call_with_http_info(**kwargs)

    def update_load_balancer(
        self,
        load_balancer_id,
        **kwargs
    ):
        """Update a Load Balancer  # noqa: E501

        Available for NSX load balancers only  Use this command to update an existing load balancer.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_load_balancer(load_balancer_id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID

        Keyword Args:
            update_load_balancer_request (UpdateLoadBalancerRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancer200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        return self.update_load_balancer_endpoint.call_with_http_info(**kwargs)

    def update_load_balancer_monitor(
        self,
        load_balancer_id,
        id,
        **kwargs
    ):
        """Update a Load Balancer Monitor  # noqa: E501

        Use this command to update an existing load balancer monitor.  This endpoint allows updating a Load Balancer Monitor. Configuration options vary by Load Balancer Type.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_load_balancer_monitor(load_balancer_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            create_load_balancer_monitor_request (CreateLoadBalancerMonitorRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerMonitor200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        kwargs['id'] = \
            id
        return self.update_load_balancer_monitor_endpoint.call_with_http_info(**kwargs)

    def update_load_balancer_pool(
        self,
        load_balancer_id,
        id,
        **kwargs
    ):
        """Update a Load Balancer Pool  # noqa: E501

        Use this command to update an existing load balancer pool.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_load_balancer_pool(load_balancer_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            create_load_balancer_pool_request (CreateLoadBalancerPoolRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerPool200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        kwargs['id'] = \
            id
        return self.update_load_balancer_pool_endpoint.call_with_http_info(**kwargs)

    def update_load_balancer_pool_node(
        self,
        load_balancer_pool_id,
        id,
        **kwargs
    ):
        """Update a Load Balancer Pool Node  # noqa: E501

        Use this command to update an existing load balancer pool node.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_load_balancer_pool_node(load_balancer_pool_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_pool_id (float): Load Balancer Pool ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            create_load_balancer_pool_node_request (CreateLoadBalancerPoolNodeRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerPoolNode200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_pool_id'] = \
            load_balancer_pool_id
        kwargs['id'] = \
            id
        return self.update_load_balancer_pool_node_endpoint.call_with_http_info(**kwargs)

    def update_load_balancer_profile(
        self,
        load_balancer_id,
        id,
        **kwargs
    ):
        """Update a Load Balancer Profile  # noqa: E501

        Use this command to update an existing load balancer Profile.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_load_balancer_profile(load_balancer_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            create_load_balancer_profile_request (CreateLoadBalancerProfileRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerProfile200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        kwargs['id'] = \
            id
        return self.update_load_balancer_profile_endpoint.call_with_http_info(**kwargs)

    def update_load_balancer_virtual_server(
        self,
        load_balancer_id,
        id,
        **kwargs
    ):
        """Update a Load Balancer Virtual Server  # noqa: E501

        Use this command to update an existing load balancer virtual server.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_load_balancer_virtual_server(load_balancer_id, id, async_req=True)
        >>> result = thread.get()

        Args:
            load_balancer_id (float): Load Balancer ID
            id (int): Morpheus ID of the Object being referenced

        Keyword Args:
            update_load_balancer_virtual_server_request (UpdateLoadBalancerVirtualServerRequest): [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _spec_property_naming (bool): True if the variable names in the input data
                are serialized names, as specified in the OpenAPI document.
                False if the variable names in the input data
                are pythonic names, e.g. snake case (default)
            _content_type (str/None): force body content-type.
                Default is None and content-type will be predicted by allowed
                content-types and body.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            _request_auths (list): set to override the auth_settings for an a single
                request; this effectively ignores the authentication
                in the spec for a single request.
                Default is None
            async_req (bool): execute request asynchronously

        Returns:
            CreateLoadBalancerVirtualServer200Response
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_spec_property_naming'] = kwargs.get(
            '_spec_property_naming', False
        )
        kwargs['_content_type'] = kwargs.get(
            '_content_type')
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['_request_auths'] = kwargs.get('_request_auths', None)
        kwargs['load_balancer_id'] = \
            load_balancer_id
        kwargs['id'] = \
            id
        return self.update_load_balancer_virtual_server_endpoint.call_with_http_info(**kwargs)

