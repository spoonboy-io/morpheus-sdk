/*
 * Morpheus API
 * Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.
 *
 * The version of the OpenAPI document: 6.2.1
 * Contact: dev@morpheusdata.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import org.openapitools.client.model.OneOfstringlong;

/**
 * The following parameters are available under the root context of the JSON body. The secret mount is capable of storing the entire JSON object as key&#x3D;value pairs, or just a single string. To store a string instead, use the value query parameter instead of JSON, or pass type&#x3D;string. There are a couple of special keys that the API will look for in the payload. The ttl key is a special key that if present in the payload will be parsed and used as the ttl parameter (lease duration in seconds). The value key is a special key that if present in the payload will be parsed and used as the secret data (instead of the entire payload). This is true when type&#x3D;string. 
 */
@ApiModel(description = "The following parameters are available under the root context of the JSON body. The secret mount is capable of storing the entire JSON object as key=value pairs, or just a single string. To store a string instead, use the value query parameter instead of JSON, or pass type=string. There are a couple of special keys that the API will look for in the payload. The ttl key is a special key that if present in the payload will be parsed and used as the ttl parameter (lease duration in seconds). The value key is a special key that if present in the payload will be parsed and used as the secret data (instead of the entire payload). This is true when type=string. ")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-08-21T11:26:47.028Z[GMT]")
public class InlineObject66 {
  public static final String SERIALIZED_NAME_TTL = "ttl";
  @SerializedName(SERIALIZED_NAME_TTL)
  private OneOfstringlong ttl = null;

  public static final String SERIALIZED_NAME_VALUE = "value";
  @SerializedName(SERIALIZED_NAME_VALUE)
  private String value;


  public InlineObject66 ttl(OneOfstringlong ttl) {
    
    this.ttl = ttl;
    return this;
  }

   /**
   * Time to Live. The lease duration in seconds, or a human readable format eg. 15m, 8h, 7d. The default is 0 meaning Never expires. This only is applied if the cypher does not yet exist and is created. 
   * @return ttl
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Time to Live. The lease duration in seconds, or a human readable format eg. 15m, 8h, 7d. The default is 0 meaning Never expires. This only is applied if the cypher does not yet exist and is created. ")

  public OneOfstringlong getTtl() {
    return ttl;
  }


  public void setTtl(OneOfstringlong ttl) {
    this.ttl = ttl;
  }


  public InlineObject66 value(String value) {
    
    this.value = value;
    return this;
  }

   /**
   * The secret value to be stored. This is only parsed if type is passed as &#x60;string&#x60;.
   * @return value
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The secret value to be stored. This is only parsed if type is passed as `string`.")

  public String getValue() {
    return value;
  }


  public void setValue(String value) {
    this.value = value;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    InlineObject66 inlineObject66 = (InlineObject66) o;
    return Objects.equals(this.ttl, inlineObject66.ttl) &&
        Objects.equals(this.value, inlineObject66.value);
  }

  @Override
  public int hashCode() {
    return Objects.hash(ttl, value);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class InlineObject66 {\n");
    sb.append("    ttl: ").append(toIndentedString(ttl)).append("\n");
    sb.append("    value: ").append(toIndentedString(value)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

