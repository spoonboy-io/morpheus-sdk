/*
 * Morpheus API
 * Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.
 *
 * The version of the OpenAPI document: 6.2.1
 * Contact: dev@morpheusdata.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.openapitools.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.math.BigDecimal;
import org.openapitools.client.model.ApiPricesPriceAccount;
import org.openapitools.client.model.ApiPricesPriceDatastore;
import org.openapitools.client.model.ApiPricesPriceVolumeType;

/**
 * ApiPricesPrice
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2023-08-21T11:26:47.028Z[GMT]")
public class ApiPricesPrice {
  public static final String SERIALIZED_NAME_NAME = "name";
  @SerializedName(SERIALIZED_NAME_NAME)
  private String name;

  public static final String SERIALIZED_NAME_CODE = "code";
  @SerializedName(SERIALIZED_NAME_CODE)
  private String code;

  public static final String SERIALIZED_NAME_ACCOUNT = "account";
  @SerializedName(SERIALIZED_NAME_ACCOUNT)
  private ApiPricesPriceAccount account;

  /**
   * Restricts query to only load only prices with specified priceType. * &#x60;fixed&#x60; - Everything * &#x60;compute&#x60; - Memory + CPU * &#x60;memory&#x60; - Memory * &#x60;cores&#x60; - Cores * &#x60;storage&#x60; - Storage * &#x60;datastore&#x60; - Datastore * &#x60;platform&#x60; - Platform * &#x60;software&#x60; - Software * &#x60;load_balancer&#x60; - Load Balancer * &#x60;load_balancer_virtual_server&#x60; - Load Balancer Virtual Server 
   */
  @JsonAdapter(PriceTypeEnum.Adapter.class)
  public enum PriceTypeEnum {
    FIXED("fixed"),
    
    COMPUTE("compute"),
    
    MEMORY("memory"),
    
    CORES("cores"),
    
    STORAGE("storage"),
    
    DATASTORE("datastore"),
    
    PLATFORM("platform"),
    
    SOFTWARE("software"),
    
    LOAD_BALANCER("load_balancer"),
    
    LOAD_BALANCER_VIRTUAL_SERVER("load_balancer_virtual_server");

    private String value;

    PriceTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PriceTypeEnum fromValue(String value) {
      for (PriceTypeEnum b : PriceTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PriceTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PriceTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PriceTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PriceTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_PRICE_TYPE = "priceType";
  @SerializedName(SERIALIZED_NAME_PRICE_TYPE)
  private PriceTypeEnum priceType;

  /**
   * The unit of pricing
   */
  @JsonAdapter(PriceUnitEnum.Adapter.class)
  public enum PriceUnitEnum {
    MINUTE("minute"),
    
    HOUR("hour"),
    
    DAY("day"),
    
    MONTH("month"),
    
    YEAR("year"),
    
    TWO_YEAR("two year"),
    
    THREE_YEAR("three year"),
    
    FOUR_YEAR("four year"),
    
    FIVE_YEAR("five year");

    private String value;

    PriceUnitEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static PriceUnitEnum fromValue(String value) {
      for (PriceUnitEnum b : PriceUnitEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<PriceUnitEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final PriceUnitEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public PriceUnitEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return PriceUnitEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_PRICE_UNIT = "priceUnit";
  @SerializedName(SERIALIZED_NAME_PRICE_UNIT)
  private PriceUnitEnum priceUnit;

  /**
   * Indicates when to incur charge
   */
  @JsonAdapter(IncurChargesEnum.Adapter.class)
  public enum IncurChargesEnum {
    RUNNING("running"),
    
    STOPPED("stopped"),
    
    ALWAYS("always");

    private String value;

    IncurChargesEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static IncurChargesEnum fromValue(String value) {
      for (IncurChargesEnum b : IncurChargesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<IncurChargesEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final IncurChargesEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public IncurChargesEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return IncurChargesEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_INCUR_CHARGES = "incurCharges";
  @SerializedName(SERIALIZED_NAME_INCUR_CHARGES)
  private IncurChargesEnum incurCharges;

  public static final String SERIALIZED_NAME_CURRENCY = "currency";
  @SerializedName(SERIALIZED_NAME_CURRENCY)
  private String currency;

  public static final String SERIALIZED_NAME_COST = "cost";
  @SerializedName(SERIALIZED_NAME_COST)
  private BigDecimal cost;

  /**
   * Price adjustment type
   */
  @JsonAdapter(MarkupTypeEnum.Adapter.class)
  public enum MarkupTypeEnum {
    FIXED("fixed"),
    
    PERCENT("percent"),
    
    CUSTOM("custom");

    private String value;

    MarkupTypeEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static MarkupTypeEnum fromValue(String value) {
      for (MarkupTypeEnum b : MarkupTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }

    public static class Adapter extends TypeAdapter<MarkupTypeEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final MarkupTypeEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public MarkupTypeEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return MarkupTypeEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_MARKUP_TYPE = "markupType";
  @SerializedName(SERIALIZED_NAME_MARKUP_TYPE)
  private MarkupTypeEnum markupType;

  public static final String SERIALIZED_NAME_MARKUP = "markup";
  @SerializedName(SERIALIZED_NAME_MARKUP)
  private BigDecimal markup;

  public static final String SERIALIZED_NAME_MARKUP_PERCENT = "markupPercent";
  @SerializedName(SERIALIZED_NAME_MARKUP_PERCENT)
  private BigDecimal markupPercent;

  public static final String SERIALIZED_NAME_CUSTOM_PRICE = "customPrice";
  @SerializedName(SERIALIZED_NAME_CUSTOM_PRICE)
  private BigDecimal customPrice;

  public static final String SERIALIZED_NAME_PLATFORM = "platform";
  @SerializedName(SERIALIZED_NAME_PLATFORM)
  private String platform;

  public static final String SERIALIZED_NAME_SOFTWARE = "software";
  @SerializedName(SERIALIZED_NAME_SOFTWARE)
  private String software;

  public static final String SERIALIZED_NAME_VOLUME_TYPE = "volumeType";
  @SerializedName(SERIALIZED_NAME_VOLUME_TYPE)
  private ApiPricesPriceVolumeType volumeType;

  public static final String SERIALIZED_NAME_DATASTORE = "datastore";
  @SerializedName(SERIALIZED_NAME_DATASTORE)
  private ApiPricesPriceDatastore datastore;

  public static final String SERIALIZED_NAME_CROSS_CLOUD_APPLY = "crossCloudApply";
  @SerializedName(SERIALIZED_NAME_CROSS_CLOUD_APPLY)
  private Boolean crossCloudApply;


  public ApiPricesPrice name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * Price name
   * @return name
  **/
  @ApiModelProperty(required = true, value = "Price name")

  public String getName() {
    return name;
  }


  public void setName(String name) {
    this.name = name;
  }


  public ApiPricesPrice code(String code) {
    
    this.code = code;
    return this;
  }

   /**
   * Price code, must be unique
   * @return code
  **/
  @ApiModelProperty(required = true, value = "Price code, must be unique")

  public String getCode() {
    return code;
  }


  public void setCode(String code) {
    this.code = code;
  }


  public ApiPricesPrice account(ApiPricesPriceAccount account) {
    
    this.account = account;
    return this;
  }

   /**
   * Get account
   * @return account
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public ApiPricesPriceAccount getAccount() {
    return account;
  }


  public void setAccount(ApiPricesPriceAccount account) {
    this.account = account;
  }


  public ApiPricesPrice priceType(PriceTypeEnum priceType) {
    
    this.priceType = priceType;
    return this;
  }

   /**
   * Restricts query to only load only prices with specified priceType. * &#x60;fixed&#x60; - Everything * &#x60;compute&#x60; - Memory + CPU * &#x60;memory&#x60; - Memory * &#x60;cores&#x60; - Cores * &#x60;storage&#x60; - Storage * &#x60;datastore&#x60; - Datastore * &#x60;platform&#x60; - Platform * &#x60;software&#x60; - Software * &#x60;load_balancer&#x60; - Load Balancer * &#x60;load_balancer_virtual_server&#x60; - Load Balancer Virtual Server 
   * @return priceType
  **/
  @ApiModelProperty(required = true, value = "Restricts query to only load only prices with specified priceType. * `fixed` - Everything * `compute` - Memory + CPU * `memory` - Memory * `cores` - Cores * `storage` - Storage * `datastore` - Datastore * `platform` - Platform * `software` - Software * `load_balancer` - Load Balancer * `load_balancer_virtual_server` - Load Balancer Virtual Server ")

  public PriceTypeEnum getPriceType() {
    return priceType;
  }


  public void setPriceType(PriceTypeEnum priceType) {
    this.priceType = priceType;
  }


  public ApiPricesPrice priceUnit(PriceUnitEnum priceUnit) {
    
    this.priceUnit = priceUnit;
    return this;
  }

   /**
   * The unit of pricing
   * @return priceUnit
  **/
  @ApiModelProperty(required = true, value = "The unit of pricing")

  public PriceUnitEnum getPriceUnit() {
    return priceUnit;
  }


  public void setPriceUnit(PriceUnitEnum priceUnit) {
    this.priceUnit = priceUnit;
  }


  public ApiPricesPrice incurCharges(IncurChargesEnum incurCharges) {
    
    this.incurCharges = incurCharges;
    return this;
  }

   /**
   * Indicates when to incur charge
   * @return incurCharges
  **/
  @ApiModelProperty(required = true, value = "Indicates when to incur charge")

  public IncurChargesEnum getIncurCharges() {
    return incurCharges;
  }


  public void setIncurCharges(IncurChargesEnum incurCharges) {
    this.incurCharges = incurCharges;
  }


  public ApiPricesPrice currency(String currency) {
    
    this.currency = currency;
    return this;
  }

   /**
   * ISO Currency code
   * @return currency
  **/
  @ApiModelProperty(example = "USD", required = true, value = "ISO Currency code")

  public String getCurrency() {
    return currency;
  }


  public void setCurrency(String currency) {
    this.currency = currency;
  }


  public ApiPricesPrice cost(BigDecimal cost) {
    
    this.cost = cost;
    return this;
  }

   /**
   * Cost
   * @return cost
  **/
  @ApiModelProperty(example = "10.5", required = true, value = "Cost")

  public BigDecimal getCost() {
    return cost;
  }


  public void setCost(BigDecimal cost) {
    this.cost = cost;
  }


  public ApiPricesPrice markupType(MarkupTypeEnum markupType) {
    
    this.markupType = markupType;
    return this;
  }

   /**
   * Price adjustment type
   * @return markupType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Price adjustment type")

  public MarkupTypeEnum getMarkupType() {
    return markupType;
  }


  public void setMarkupType(MarkupTypeEnum markupType) {
    this.markupType = markupType;
  }


  public ApiPricesPrice markup(BigDecimal markup) {
    
    this.markup = markup;
    return this;
  }

   /**
   * Amount for &#x60;fixed&#x60; price adjustment type
   * @return markup
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "2.5", value = "Amount for `fixed` price adjustment type")

  public BigDecimal getMarkup() {
    return markup;
  }


  public void setMarkup(BigDecimal markup) {
    this.markup = markup;
  }


  public ApiPricesPrice markupPercent(BigDecimal markupPercent) {
    
    this.markupPercent = markupPercent;
    return this;
  }

   /**
   * Percent for &#x60;percent&#x60; price adjustment type
   * @return markupPercent
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "13.5", value = "Percent for `percent` price adjustment type")

  public BigDecimal getMarkupPercent() {
    return markupPercent;
  }


  public void setMarkupPercent(BigDecimal markupPercent) {
    this.markupPercent = markupPercent;
  }


  public ApiPricesPrice customPrice(BigDecimal customPrice) {
    
    this.customPrice = customPrice;
    return this;
  }

   /**
   * Custom price for &#x60;custom&#x60; price adjustment type
   * @return customPrice
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "12.25", value = "Custom price for `custom` price adjustment type")

  public BigDecimal getCustomPrice() {
    return customPrice;
  }


  public void setCustomPrice(BigDecimal customPrice) {
    this.customPrice = customPrice;
  }


  public ApiPricesPrice platform(String platform) {
    
    this.platform = platform;
    return this;
  }

   /**
   * Platform.  Required for &#x60;platform&#x60; price type
   * @return platform
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(example = "linux", value = "Platform.  Required for `platform` price type")

  public String getPlatform() {
    return platform;
  }


  public void setPlatform(String platform) {
    this.platform = platform;
  }


  public ApiPricesPrice software(String software) {
    
    this.software = software;
    return this;
  }

   /**
   * Software.  Required for software price type
   * @return software
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Software.  Required for software price type")

  public String getSoftware() {
    return software;
  }


  public void setSoftware(String software) {
    this.software = software;
  }


  public ApiPricesPrice volumeType(ApiPricesPriceVolumeType volumeType) {
    
    this.volumeType = volumeType;
    return this;
  }

   /**
   * Get volumeType
   * @return volumeType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public ApiPricesPriceVolumeType getVolumeType() {
    return volumeType;
  }


  public void setVolumeType(ApiPricesPriceVolumeType volumeType) {
    this.volumeType = volumeType;
  }


  public ApiPricesPrice datastore(ApiPricesPriceDatastore datastore) {
    
    this.datastore = datastore;
    return this;
  }

   /**
   * Get datastore
   * @return datastore
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")

  public ApiPricesPriceDatastore getDatastore() {
    return datastore;
  }


  public void setDatastore(ApiPricesPriceDatastore datastore) {
    this.datastore = datastore;
  }


  public ApiPricesPrice crossCloudApply(Boolean crossCloudApply) {
    
    this.crossCloudApply = crossCloudApply;
    return this;
  }

   /**
   * Apply price across clouds, optional true/false flag for datastore price type
   * @return crossCloudApply
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Apply price across clouds, optional true/false flag for datastore price type")

  public Boolean getCrossCloudApply() {
    return crossCloudApply;
  }


  public void setCrossCloudApply(Boolean crossCloudApply) {
    this.crossCloudApply = crossCloudApply;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApiPricesPrice apiPricesPrice = (ApiPricesPrice) o;
    return Objects.equals(this.name, apiPricesPrice.name) &&
        Objects.equals(this.code, apiPricesPrice.code) &&
        Objects.equals(this.account, apiPricesPrice.account) &&
        Objects.equals(this.priceType, apiPricesPrice.priceType) &&
        Objects.equals(this.priceUnit, apiPricesPrice.priceUnit) &&
        Objects.equals(this.incurCharges, apiPricesPrice.incurCharges) &&
        Objects.equals(this.currency, apiPricesPrice.currency) &&
        Objects.equals(this.cost, apiPricesPrice.cost) &&
        Objects.equals(this.markupType, apiPricesPrice.markupType) &&
        Objects.equals(this.markup, apiPricesPrice.markup) &&
        Objects.equals(this.markupPercent, apiPricesPrice.markupPercent) &&
        Objects.equals(this.customPrice, apiPricesPrice.customPrice) &&
        Objects.equals(this.platform, apiPricesPrice.platform) &&
        Objects.equals(this.software, apiPricesPrice.software) &&
        Objects.equals(this.volumeType, apiPricesPrice.volumeType) &&
        Objects.equals(this.datastore, apiPricesPrice.datastore) &&
        Objects.equals(this.crossCloudApply, apiPricesPrice.crossCloudApply);
  }

  @Override
  public int hashCode() {
    return Objects.hash(name, code, account, priceType, priceUnit, incurCharges, currency, cost, markupType, markup, markupPercent, customPrice, platform, software, volumeType, datastore, crossCloudApply);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApiPricesPrice {\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    code: ").append(toIndentedString(code)).append("\n");
    sb.append("    account: ").append(toIndentedString(account)).append("\n");
    sb.append("    priceType: ").append(toIndentedString(priceType)).append("\n");
    sb.append("    priceUnit: ").append(toIndentedString(priceUnit)).append("\n");
    sb.append("    incurCharges: ").append(toIndentedString(incurCharges)).append("\n");
    sb.append("    currency: ").append(toIndentedString(currency)).append("\n");
    sb.append("    cost: ").append(toIndentedString(cost)).append("\n");
    sb.append("    markupType: ").append(toIndentedString(markupType)).append("\n");
    sb.append("    markup: ").append(toIndentedString(markup)).append("\n");
    sb.append("    markupPercent: ").append(toIndentedString(markupPercent)).append("\n");
    sb.append("    customPrice: ").append(toIndentedString(customPrice)).append("\n");
    sb.append("    platform: ").append(toIndentedString(platform)).append("\n");
    sb.append("    software: ").append(toIndentedString(software)).append("\n");
    sb.append("    volumeType: ").append(toIndentedString(volumeType)).append("\n");
    sb.append("    datastore: ").append(toIndentedString(datastore)).append("\n");
    sb.append("    crossCloudApply: ").append(toIndentedString(crossCloudApply)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

