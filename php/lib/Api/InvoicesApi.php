<?php
/**
 * InvoicesApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Morpheus API
 *
 * Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.
 *
 * The version of the OpenAPI document: 6.2.1
 * Contact: dev@morpheusdata.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * InvoicesApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class InvoicesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getInvoiceLineItems
     *
     * Get a Specific Invoice Line Item
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function getInvoiceLineItems($id)
    {
        list($response) = $this->getInvoiceLineItemsWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getInvoiceLineItemsWithHttpInfo
     *
     * Get a Specific Invoice Line Item
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoiceLineItemsWithHttpInfo($id)
    {
        $request = $this->getInvoiceLineItemsRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoiceLineItemsAsync
     *
     * Get a Specific Invoice Line Item
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceLineItemsAsync($id)
    {
        return $this->getInvoiceLineItemsAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoiceLineItemsAsyncWithHttpInfo
     *
     * Get a Specific Invoice Line Item
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoiceLineItemsAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getInvoiceLineItemsRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoiceLineItems'
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInvoiceLineItemsRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getInvoiceLineItems'
            );
        }

        $resourcePath = '/api/invoice-line-items/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getInvoices
     *
     * Get a Specific Invoice
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function getInvoices($id)
    {
        list($response) = $this->getInvoicesWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getInvoicesWithHttpInfo
     *
     * Get a Specific Invoice
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getInvoicesWithHttpInfo($id)
    {
        $request = $this->getInvoicesRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getInvoicesAsync
     *
     * Get a Specific Invoice
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoicesAsync($id)
    {
        return $this->getInvoicesAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getInvoicesAsyncWithHttpInfo
     *
     * Get a Specific Invoice
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getInvoicesAsyncWithHttpInfo($id)
    {
        $returnType = 'object';
        $request = $this->getInvoicesRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getInvoices'
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getInvoicesRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getInvoices'
            );
        }

        $resourcePath = '/api/invoices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listInvoiceLineItems
     *
     * List All Invoice Line Items
     *
     * @param  int $max Maximum number of records to return, -1 can be used to fetch all records (optional, default to 25)
     * @param  int $offset Offset records, the number of records to skip, for paginating requests (optional, default to 0)
     * @param  string $sort Sort order, the name of the property to sort by (optional, default to 'name')
     * @param  string $direction Sort direction, use &#39;desc&#39; to reverse sort (optional, default to 'asc')
     * @param  string $phrase Search phrase for partial matches on name or description (optional)
     * @param  string $name Filter by name, wildcard may be specified as %, eg. example-% (optional)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  string $period Only return records for period that matches with the specified value. This is an alternative to using startDate/endDate. Format is YYYY or YYYYMM. (optional)
     * @param  string $ref_type If specified will return an exact match on refType. (optional)
     * @param  int $ref_id If specified will return an exact match on refId (optional)
     * @param  int $zone_id The Zone ID for Filtering (optional)
     * @param  int $site_id The Site ID for Filtering (optional)
     * @param  int $instance_id The Instance ID for Filtering (optional)
     * @param  int $container_id The Container ID for Filtering (optional)
     * @param  int $server_id The Server ID for Filtering (optional)
     * @param  int $user_id Filter by User ID (optional)
     * @param  int $project_id The Project ID for Filtering (optional)
     * @param  bool $active True or False flag for Active (optional)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     * @param  bool $include_totals Pass true to include the summed totals (cost/price values) for all the invoices found in the query. The returned property is called &#x60;invoiceTotals&#x60;. (optional, default to false)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function listInvoiceLineItems($max = 25, $offset = 0, $sort = 'name', $direction = 'asc', $phrase = null, $name = null, $start_date = null, $end_date = null, $period = null, $ref_type = null, $ref_id = null, $zone_id = null, $site_id = null, $instance_id = null, $container_id = null, $server_id = null, $user_id = null, $project_id = null, $active = null, $account_id = null, $include_totals = false)
    {
        list($response) = $this->listInvoiceLineItemsWithHttpInfo($max, $offset, $sort, $direction, $phrase, $name, $start_date, $end_date, $period, $ref_type, $ref_id, $zone_id, $site_id, $instance_id, $container_id, $server_id, $user_id, $project_id, $active, $account_id, $include_totals);
        return $response;
    }

    /**
     * Operation listInvoiceLineItemsWithHttpInfo
     *
     * List All Invoice Line Items
     *
     * @param  int $max Maximum number of records to return, -1 can be used to fetch all records (optional, default to 25)
     * @param  int $offset Offset records, the number of records to skip, for paginating requests (optional, default to 0)
     * @param  string $sort Sort order, the name of the property to sort by (optional, default to 'name')
     * @param  string $direction Sort direction, use &#39;desc&#39; to reverse sort (optional, default to 'asc')
     * @param  string $phrase Search phrase for partial matches on name or description (optional)
     * @param  string $name Filter by name, wildcard may be specified as %, eg. example-% (optional)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  string $period Only return records for period that matches with the specified value. This is an alternative to using startDate/endDate. Format is YYYY or YYYYMM. (optional)
     * @param  string $ref_type If specified will return an exact match on refType. (optional)
     * @param  int $ref_id If specified will return an exact match on refId (optional)
     * @param  int $zone_id The Zone ID for Filtering (optional)
     * @param  int $site_id The Site ID for Filtering (optional)
     * @param  int $instance_id The Instance ID for Filtering (optional)
     * @param  int $container_id The Container ID for Filtering (optional)
     * @param  int $server_id The Server ID for Filtering (optional)
     * @param  int $user_id Filter by User ID (optional)
     * @param  int $project_id The Project ID for Filtering (optional)
     * @param  bool $active True or False flag for Active (optional)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     * @param  bool $include_totals Pass true to include the summed totals (cost/price values) for all the invoices found in the query. The returned property is called &#x60;invoiceTotals&#x60;. (optional, default to false)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function listInvoiceLineItemsWithHttpInfo($max = 25, $offset = 0, $sort = 'name', $direction = 'asc', $phrase = null, $name = null, $start_date = null, $end_date = null, $period = null, $ref_type = null, $ref_id = null, $zone_id = null, $site_id = null, $instance_id = null, $container_id = null, $server_id = null, $user_id = null, $project_id = null, $active = null, $account_id = null, $include_totals = false)
    {
        $request = $this->listInvoiceLineItemsRequest($max, $offset, $sort, $direction, $phrase, $name, $start_date, $end_date, $period, $ref_type, $ref_id, $zone_id, $site_id, $instance_id, $container_id, $server_id, $user_id, $project_id, $active, $account_id, $include_totals);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listInvoiceLineItemsAsync
     *
     * List All Invoice Line Items
     *
     * @param  int $max Maximum number of records to return, -1 can be used to fetch all records (optional, default to 25)
     * @param  int $offset Offset records, the number of records to skip, for paginating requests (optional, default to 0)
     * @param  string $sort Sort order, the name of the property to sort by (optional, default to 'name')
     * @param  string $direction Sort direction, use &#39;desc&#39; to reverse sort (optional, default to 'asc')
     * @param  string $phrase Search phrase for partial matches on name or description (optional)
     * @param  string $name Filter by name, wildcard may be specified as %, eg. example-% (optional)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  string $period Only return records for period that matches with the specified value. This is an alternative to using startDate/endDate. Format is YYYY or YYYYMM. (optional)
     * @param  string $ref_type If specified will return an exact match on refType. (optional)
     * @param  int $ref_id If specified will return an exact match on refId (optional)
     * @param  int $zone_id The Zone ID for Filtering (optional)
     * @param  int $site_id The Site ID for Filtering (optional)
     * @param  int $instance_id The Instance ID for Filtering (optional)
     * @param  int $container_id The Container ID for Filtering (optional)
     * @param  int $server_id The Server ID for Filtering (optional)
     * @param  int $user_id Filter by User ID (optional)
     * @param  int $project_id The Project ID for Filtering (optional)
     * @param  bool $active True or False flag for Active (optional)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     * @param  bool $include_totals Pass true to include the summed totals (cost/price values) for all the invoices found in the query. The returned property is called &#x60;invoiceTotals&#x60;. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInvoiceLineItemsAsync($max = 25, $offset = 0, $sort = 'name', $direction = 'asc', $phrase = null, $name = null, $start_date = null, $end_date = null, $period = null, $ref_type = null, $ref_id = null, $zone_id = null, $site_id = null, $instance_id = null, $container_id = null, $server_id = null, $user_id = null, $project_id = null, $active = null, $account_id = null, $include_totals = false)
    {
        return $this->listInvoiceLineItemsAsyncWithHttpInfo($max, $offset, $sort, $direction, $phrase, $name, $start_date, $end_date, $period, $ref_type, $ref_id, $zone_id, $site_id, $instance_id, $container_id, $server_id, $user_id, $project_id, $active, $account_id, $include_totals)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listInvoiceLineItemsAsyncWithHttpInfo
     *
     * List All Invoice Line Items
     *
     * @param  int $max Maximum number of records to return, -1 can be used to fetch all records (optional, default to 25)
     * @param  int $offset Offset records, the number of records to skip, for paginating requests (optional, default to 0)
     * @param  string $sort Sort order, the name of the property to sort by (optional, default to 'name')
     * @param  string $direction Sort direction, use &#39;desc&#39; to reverse sort (optional, default to 'asc')
     * @param  string $phrase Search phrase for partial matches on name or description (optional)
     * @param  string $name Filter by name, wildcard may be specified as %, eg. example-% (optional)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  string $period Only return records for period that matches with the specified value. This is an alternative to using startDate/endDate. Format is YYYY or YYYYMM. (optional)
     * @param  string $ref_type If specified will return an exact match on refType. (optional)
     * @param  int $ref_id If specified will return an exact match on refId (optional)
     * @param  int $zone_id The Zone ID for Filtering (optional)
     * @param  int $site_id The Site ID for Filtering (optional)
     * @param  int $instance_id The Instance ID for Filtering (optional)
     * @param  int $container_id The Container ID for Filtering (optional)
     * @param  int $server_id The Server ID for Filtering (optional)
     * @param  int $user_id Filter by User ID (optional)
     * @param  int $project_id The Project ID for Filtering (optional)
     * @param  bool $active True or False flag for Active (optional)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     * @param  bool $include_totals Pass true to include the summed totals (cost/price values) for all the invoices found in the query. The returned property is called &#x60;invoiceTotals&#x60;. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInvoiceLineItemsAsyncWithHttpInfo($max = 25, $offset = 0, $sort = 'name', $direction = 'asc', $phrase = null, $name = null, $start_date = null, $end_date = null, $period = null, $ref_type = null, $ref_id = null, $zone_id = null, $site_id = null, $instance_id = null, $container_id = null, $server_id = null, $user_id = null, $project_id = null, $active = null, $account_id = null, $include_totals = false)
    {
        $returnType = 'object';
        $request = $this->listInvoiceLineItemsRequest($max, $offset, $sort, $direction, $phrase, $name, $start_date, $end_date, $period, $ref_type, $ref_id, $zone_id, $site_id, $instance_id, $container_id, $server_id, $user_id, $project_id, $active, $account_id, $include_totals);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listInvoiceLineItems'
     *
     * @param  int $max Maximum number of records to return, -1 can be used to fetch all records (optional, default to 25)
     * @param  int $offset Offset records, the number of records to skip, for paginating requests (optional, default to 0)
     * @param  string $sort Sort order, the name of the property to sort by (optional, default to 'name')
     * @param  string $direction Sort direction, use &#39;desc&#39; to reverse sort (optional, default to 'asc')
     * @param  string $phrase Search phrase for partial matches on name or description (optional)
     * @param  string $name Filter by name, wildcard may be specified as %, eg. example-% (optional)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  string $period Only return records for period that matches with the specified value. This is an alternative to using startDate/endDate. Format is YYYY or YYYYMM. (optional)
     * @param  string $ref_type If specified will return an exact match on refType. (optional)
     * @param  int $ref_id If specified will return an exact match on refId (optional)
     * @param  int $zone_id The Zone ID for Filtering (optional)
     * @param  int $site_id The Site ID for Filtering (optional)
     * @param  int $instance_id The Instance ID for Filtering (optional)
     * @param  int $container_id The Container ID for Filtering (optional)
     * @param  int $server_id The Server ID for Filtering (optional)
     * @param  int $user_id Filter by User ID (optional)
     * @param  int $project_id The Project ID for Filtering (optional)
     * @param  bool $active True or False flag for Active (optional)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     * @param  bool $include_totals Pass true to include the summed totals (cost/price values) for all the invoices found in the query. The returned property is called &#x60;invoiceTotals&#x60;. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listInvoiceLineItemsRequest($max = 25, $offset = 0, $sort = 'name', $direction = 'asc', $phrase = null, $name = null, $start_date = null, $end_date = null, $period = null, $ref_type = null, $ref_id = null, $zone_id = null, $site_id = null, $instance_id = null, $container_id = null, $server_id = null, $user_id = null, $project_id = null, $active = null, $account_id = null, $include_totals = false)
    {

        $resourcePath = '/api/invoice-line-items';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($max !== null) {
            if('form' === 'form' && is_array($max)) {
                foreach($max as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['max'] = $max;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($direction !== null) {
            if('form' === 'form' && is_array($direction)) {
                foreach($direction as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['direction'] = $direction;
            }
        }
        // query params
        if ($phrase !== null) {
            if('form' === 'form' && is_array($phrase)) {
                foreach($phrase as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['phrase'] = $phrase;
            }
        }
        // query params
        if ($name !== null) {
            if('form' === 'form' && is_array($name)) {
                foreach($name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['name'] = $name;
            }
        }
        // query params
        if ($start_date !== null) {
            if('form' === 'form' && is_array($start_date)) {
                foreach($start_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startDate'] = $start_date;
            }
        }
        // query params
        if ($end_date !== null) {
            if('form' === 'form' && is_array($end_date)) {
                foreach($end_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['endDate'] = $end_date;
            }
        }
        // query params
        if ($period !== null) {
            if('form' === 'form' && is_array($period)) {
                foreach($period as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['period'] = $period;
            }
        }
        // query params
        if ($ref_type !== null) {
            if('form' === 'form' && is_array($ref_type)) {
                foreach($ref_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['refType'] = $ref_type;
            }
        }
        // query params
        if ($ref_id !== null) {
            if('form' === 'form' && is_array($ref_id)) {
                foreach($ref_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['refId'] = $ref_id;
            }
        }
        // query params
        if ($zone_id !== null) {
            if('form' === 'form' && is_array($zone_id)) {
                foreach($zone_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['zoneId'] = $zone_id;
            }
        }
        // query params
        if ($site_id !== null) {
            if('form' === 'form' && is_array($site_id)) {
                foreach($site_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['siteId'] = $site_id;
            }
        }
        // query params
        if ($instance_id !== null) {
            if('form' === 'form' && is_array($instance_id)) {
                foreach($instance_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['instanceId'] = $instance_id;
            }
        }
        // query params
        if ($container_id !== null) {
            if('form' === 'form' && is_array($container_id)) {
                foreach($container_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['containerId'] = $container_id;
            }
        }
        // query params
        if ($server_id !== null) {
            if('form' === 'form' && is_array($server_id)) {
                foreach($server_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['serverId'] = $server_id;
            }
        }
        // query params
        if ($user_id !== null) {
            if('form' === 'form' && is_array($user_id)) {
                foreach($user_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userId'] = $user_id;
            }
        }
        // query params
        if ($project_id !== null) {
            if('form' === 'form' && is_array($project_id)) {
                foreach($project_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['projectId'] = $project_id;
            }
        }
        // query params
        if ($active !== null) {
            if('form' === 'form' && is_array($active)) {
                foreach($active as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['active'] = $active;
            }
        }
        // query params
        if ($account_id !== null) {
            if('form' === 'form' && is_array($account_id)) {
                foreach($account_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['accountId'] = $account_id;
            }
        }
        // query params
        if ($include_totals !== null) {
            if('form' === 'form' && is_array($include_totals)) {
                foreach($include_totals as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeTotals'] = $include_totals;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listInvoices
     *
     * List All Invoices
     *
     * @param  int $max Maximum number of records to return, -1 can be used to fetch all records (optional, default to 25)
     * @param  int $offset Offset records, the number of records to skip, for paginating requests (optional, default to 0)
     * @param  string $sort Sort order, the name of the property to sort by (optional, default to 'refName')
     * @param  string $direction Sort direction, use &#39;desc&#39; to reverse sort (optional, default to 'asc')
     * @param  string $phrase Search phrase for partial matches on name or description (optional)
     * @param  string $name Filter by name, wildcard may be specified as %, eg. example-% (optional)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  string $period Only return records for period that matches with the specified value. This is an alternative to using startDate/endDate. Format is YYYY or YYYYMM. (optional)
     * @param  string $ref_type If specified will return an exact match on refType. (optional)
     * @param  int $ref_id If specified will return an exact match on refId (optional)
     * @param  string $ref_status If specified, will filter on the associated StorageVolume status. This is only applicable whn &#x60;refType&#x3D;StorageVolume&#x60;. (optional)
     * @param  int $zone_id The Zone ID for Filtering (optional)
     * @param  int $site_id The Site ID for Filtering (optional)
     * @param  int $instance_id The Instance ID for Filtering (optional)
     * @param  int $container_id The Container ID for Filtering (optional)
     * @param  int $server_id The Server ID for Filtering (optional)
     * @param  int $user_id Filter by User ID (optional)
     * @param  int $project_id The Project ID for Filtering (optional)
     * @param  bool $active True or False flag for Active (optional)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     * @param  bool $include_line_items Pass true to include the list of &#x60;lineItems&#x60; for each invoice. Only &#x60;lineItemCount&#x60; is returned by default. (optional, default to false)
     * @param  bool $include_totals Pass true to include the summed totals (cost/price values) for all the invoices found in the query. The returned property is called &#x60;invoiceTotals&#x60;. (optional, default to false)
     * @param  string $tags Filter by tags (metadata). This allows filtering by a tag name and value(s) (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function listInvoices($max = 25, $offset = 0, $sort = 'refName', $direction = 'asc', $phrase = null, $name = null, $start_date = null, $end_date = null, $period = null, $ref_type = null, $ref_id = null, $ref_status = null, $zone_id = null, $site_id = null, $instance_id = null, $container_id = null, $server_id = null, $user_id = null, $project_id = null, $active = null, $account_id = null, $include_line_items = false, $include_totals = false, $tags = null)
    {
        list($response) = $this->listInvoicesWithHttpInfo($max, $offset, $sort, $direction, $phrase, $name, $start_date, $end_date, $period, $ref_type, $ref_id, $ref_status, $zone_id, $site_id, $instance_id, $container_id, $server_id, $user_id, $project_id, $active, $account_id, $include_line_items, $include_totals, $tags);
        return $response;
    }

    /**
     * Operation listInvoicesWithHttpInfo
     *
     * List All Invoices
     *
     * @param  int $max Maximum number of records to return, -1 can be used to fetch all records (optional, default to 25)
     * @param  int $offset Offset records, the number of records to skip, for paginating requests (optional, default to 0)
     * @param  string $sort Sort order, the name of the property to sort by (optional, default to 'refName')
     * @param  string $direction Sort direction, use &#39;desc&#39; to reverse sort (optional, default to 'asc')
     * @param  string $phrase Search phrase for partial matches on name or description (optional)
     * @param  string $name Filter by name, wildcard may be specified as %, eg. example-% (optional)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  string $period Only return records for period that matches with the specified value. This is an alternative to using startDate/endDate. Format is YYYY or YYYYMM. (optional)
     * @param  string $ref_type If specified will return an exact match on refType. (optional)
     * @param  int $ref_id If specified will return an exact match on refId (optional)
     * @param  string $ref_status If specified, will filter on the associated StorageVolume status. This is only applicable whn &#x60;refType&#x3D;StorageVolume&#x60;. (optional)
     * @param  int $zone_id The Zone ID for Filtering (optional)
     * @param  int $site_id The Site ID for Filtering (optional)
     * @param  int $instance_id The Instance ID for Filtering (optional)
     * @param  int $container_id The Container ID for Filtering (optional)
     * @param  int $server_id The Server ID for Filtering (optional)
     * @param  int $user_id Filter by User ID (optional)
     * @param  int $project_id The Project ID for Filtering (optional)
     * @param  bool $active True or False flag for Active (optional)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     * @param  bool $include_line_items Pass true to include the list of &#x60;lineItems&#x60; for each invoice. Only &#x60;lineItemCount&#x60; is returned by default. (optional, default to false)
     * @param  bool $include_totals Pass true to include the summed totals (cost/price values) for all the invoices found in the query. The returned property is called &#x60;invoiceTotals&#x60;. (optional, default to false)
     * @param  string $tags Filter by tags (metadata). This allows filtering by a tag name and value(s) (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function listInvoicesWithHttpInfo($max = 25, $offset = 0, $sort = 'refName', $direction = 'asc', $phrase = null, $name = null, $start_date = null, $end_date = null, $period = null, $ref_type = null, $ref_id = null, $ref_status = null, $zone_id = null, $site_id = null, $instance_id = null, $container_id = null, $server_id = null, $user_id = null, $project_id = null, $active = null, $account_id = null, $include_line_items = false, $include_totals = false, $tags = null)
    {
        $request = $this->listInvoicesRequest($max, $offset, $sort, $direction, $phrase, $name, $start_date, $end_date, $period, $ref_type, $ref_id, $ref_status, $zone_id, $site_id, $instance_id, $container_id, $server_id, $user_id, $project_id, $active, $account_id, $include_line_items, $include_totals, $tags);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listInvoicesAsync
     *
     * List All Invoices
     *
     * @param  int $max Maximum number of records to return, -1 can be used to fetch all records (optional, default to 25)
     * @param  int $offset Offset records, the number of records to skip, for paginating requests (optional, default to 0)
     * @param  string $sort Sort order, the name of the property to sort by (optional, default to 'refName')
     * @param  string $direction Sort direction, use &#39;desc&#39; to reverse sort (optional, default to 'asc')
     * @param  string $phrase Search phrase for partial matches on name or description (optional)
     * @param  string $name Filter by name, wildcard may be specified as %, eg. example-% (optional)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  string $period Only return records for period that matches with the specified value. This is an alternative to using startDate/endDate. Format is YYYY or YYYYMM. (optional)
     * @param  string $ref_type If specified will return an exact match on refType. (optional)
     * @param  int $ref_id If specified will return an exact match on refId (optional)
     * @param  string $ref_status If specified, will filter on the associated StorageVolume status. This is only applicable whn &#x60;refType&#x3D;StorageVolume&#x60;. (optional)
     * @param  int $zone_id The Zone ID for Filtering (optional)
     * @param  int $site_id The Site ID for Filtering (optional)
     * @param  int $instance_id The Instance ID for Filtering (optional)
     * @param  int $container_id The Container ID for Filtering (optional)
     * @param  int $server_id The Server ID for Filtering (optional)
     * @param  int $user_id Filter by User ID (optional)
     * @param  int $project_id The Project ID for Filtering (optional)
     * @param  bool $active True or False flag for Active (optional)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     * @param  bool $include_line_items Pass true to include the list of &#x60;lineItems&#x60; for each invoice. Only &#x60;lineItemCount&#x60; is returned by default. (optional, default to false)
     * @param  bool $include_totals Pass true to include the summed totals (cost/price values) for all the invoices found in the query. The returned property is called &#x60;invoiceTotals&#x60;. (optional, default to false)
     * @param  string $tags Filter by tags (metadata). This allows filtering by a tag name and value(s) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInvoicesAsync($max = 25, $offset = 0, $sort = 'refName', $direction = 'asc', $phrase = null, $name = null, $start_date = null, $end_date = null, $period = null, $ref_type = null, $ref_id = null, $ref_status = null, $zone_id = null, $site_id = null, $instance_id = null, $container_id = null, $server_id = null, $user_id = null, $project_id = null, $active = null, $account_id = null, $include_line_items = false, $include_totals = false, $tags = null)
    {
        return $this->listInvoicesAsyncWithHttpInfo($max, $offset, $sort, $direction, $phrase, $name, $start_date, $end_date, $period, $ref_type, $ref_id, $ref_status, $zone_id, $site_id, $instance_id, $container_id, $server_id, $user_id, $project_id, $active, $account_id, $include_line_items, $include_totals, $tags)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listInvoicesAsyncWithHttpInfo
     *
     * List All Invoices
     *
     * @param  int $max Maximum number of records to return, -1 can be used to fetch all records (optional, default to 25)
     * @param  int $offset Offset records, the number of records to skip, for paginating requests (optional, default to 0)
     * @param  string $sort Sort order, the name of the property to sort by (optional, default to 'refName')
     * @param  string $direction Sort direction, use &#39;desc&#39; to reverse sort (optional, default to 'asc')
     * @param  string $phrase Search phrase for partial matches on name or description (optional)
     * @param  string $name Filter by name, wildcard may be specified as %, eg. example-% (optional)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  string $period Only return records for period that matches with the specified value. This is an alternative to using startDate/endDate. Format is YYYY or YYYYMM. (optional)
     * @param  string $ref_type If specified will return an exact match on refType. (optional)
     * @param  int $ref_id If specified will return an exact match on refId (optional)
     * @param  string $ref_status If specified, will filter on the associated StorageVolume status. This is only applicable whn &#x60;refType&#x3D;StorageVolume&#x60;. (optional)
     * @param  int $zone_id The Zone ID for Filtering (optional)
     * @param  int $site_id The Site ID for Filtering (optional)
     * @param  int $instance_id The Instance ID for Filtering (optional)
     * @param  int $container_id The Container ID for Filtering (optional)
     * @param  int $server_id The Server ID for Filtering (optional)
     * @param  int $user_id Filter by User ID (optional)
     * @param  int $project_id The Project ID for Filtering (optional)
     * @param  bool $active True or False flag for Active (optional)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     * @param  bool $include_line_items Pass true to include the list of &#x60;lineItems&#x60; for each invoice. Only &#x60;lineItemCount&#x60; is returned by default. (optional, default to false)
     * @param  bool $include_totals Pass true to include the summed totals (cost/price values) for all the invoices found in the query. The returned property is called &#x60;invoiceTotals&#x60;. (optional, default to false)
     * @param  string $tags Filter by tags (metadata). This allows filtering by a tag name and value(s) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listInvoicesAsyncWithHttpInfo($max = 25, $offset = 0, $sort = 'refName', $direction = 'asc', $phrase = null, $name = null, $start_date = null, $end_date = null, $period = null, $ref_type = null, $ref_id = null, $ref_status = null, $zone_id = null, $site_id = null, $instance_id = null, $container_id = null, $server_id = null, $user_id = null, $project_id = null, $active = null, $account_id = null, $include_line_items = false, $include_totals = false, $tags = null)
    {
        $returnType = 'object';
        $request = $this->listInvoicesRequest($max, $offset, $sort, $direction, $phrase, $name, $start_date, $end_date, $period, $ref_type, $ref_id, $ref_status, $zone_id, $site_id, $instance_id, $container_id, $server_id, $user_id, $project_id, $active, $account_id, $include_line_items, $include_totals, $tags);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listInvoices'
     *
     * @param  int $max Maximum number of records to return, -1 can be used to fetch all records (optional, default to 25)
     * @param  int $offset Offset records, the number of records to skip, for paginating requests (optional, default to 0)
     * @param  string $sort Sort order, the name of the property to sort by (optional, default to 'refName')
     * @param  string $direction Sort direction, use &#39;desc&#39; to reverse sort (optional, default to 'asc')
     * @param  string $phrase Search phrase for partial matches on name or description (optional)
     * @param  string $name Filter by name, wildcard may be specified as %, eg. example-% (optional)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  string $period Only return records for period that matches with the specified value. This is an alternative to using startDate/endDate. Format is YYYY or YYYYMM. (optional)
     * @param  string $ref_type If specified will return an exact match on refType. (optional)
     * @param  int $ref_id If specified will return an exact match on refId (optional)
     * @param  string $ref_status If specified, will filter on the associated StorageVolume status. This is only applicable whn &#x60;refType&#x3D;StorageVolume&#x60;. (optional)
     * @param  int $zone_id The Zone ID for Filtering (optional)
     * @param  int $site_id The Site ID for Filtering (optional)
     * @param  int $instance_id The Instance ID for Filtering (optional)
     * @param  int $container_id The Container ID for Filtering (optional)
     * @param  int $server_id The Server ID for Filtering (optional)
     * @param  int $user_id Filter by User ID (optional)
     * @param  int $project_id The Project ID for Filtering (optional)
     * @param  bool $active True or False flag for Active (optional)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     * @param  bool $include_line_items Pass true to include the list of &#x60;lineItems&#x60; for each invoice. Only &#x60;lineItemCount&#x60; is returned by default. (optional, default to false)
     * @param  bool $include_totals Pass true to include the summed totals (cost/price values) for all the invoices found in the query. The returned property is called &#x60;invoiceTotals&#x60;. (optional, default to false)
     * @param  string $tags Filter by tags (metadata). This allows filtering by a tag name and value(s) (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listInvoicesRequest($max = 25, $offset = 0, $sort = 'refName', $direction = 'asc', $phrase = null, $name = null, $start_date = null, $end_date = null, $period = null, $ref_type = null, $ref_id = null, $ref_status = null, $zone_id = null, $site_id = null, $instance_id = null, $container_id = null, $server_id = null, $user_id = null, $project_id = null, $active = null, $account_id = null, $include_line_items = false, $include_totals = false, $tags = null)
    {

        $resourcePath = '/api/invoices';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($max !== null) {
            if('form' === 'form' && is_array($max)) {
                foreach($max as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['max'] = $max;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }
        // query params
        if ($sort !== null) {
            if('form' === 'form' && is_array($sort)) {
                foreach($sort as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sort'] = $sort;
            }
        }
        // query params
        if ($direction !== null) {
            if('form' === 'form' && is_array($direction)) {
                foreach($direction as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['direction'] = $direction;
            }
        }
        // query params
        if ($phrase !== null) {
            if('form' === 'form' && is_array($phrase)) {
                foreach($phrase as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['phrase'] = $phrase;
            }
        }
        // query params
        if ($name !== null) {
            if('form' === 'form' && is_array($name)) {
                foreach($name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['name'] = $name;
            }
        }
        // query params
        if ($start_date !== null) {
            if('form' === 'form' && is_array($start_date)) {
                foreach($start_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startDate'] = $start_date;
            }
        }
        // query params
        if ($end_date !== null) {
            if('form' === 'form' && is_array($end_date)) {
                foreach($end_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['endDate'] = $end_date;
            }
        }
        // query params
        if ($period !== null) {
            if('form' === 'form' && is_array($period)) {
                foreach($period as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['period'] = $period;
            }
        }
        // query params
        if ($ref_type !== null) {
            if('form' === 'form' && is_array($ref_type)) {
                foreach($ref_type as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['refType'] = $ref_type;
            }
        }
        // query params
        if ($ref_id !== null) {
            if('form' === 'form' && is_array($ref_id)) {
                foreach($ref_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['refId'] = $ref_id;
            }
        }
        // query params
        if ($ref_status !== null) {
            if('form' === 'form' && is_array($ref_status)) {
                foreach($ref_status as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['refStatus'] = $ref_status;
            }
        }
        // query params
        if ($zone_id !== null) {
            if('form' === 'form' && is_array($zone_id)) {
                foreach($zone_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['zoneId'] = $zone_id;
            }
        }
        // query params
        if ($site_id !== null) {
            if('form' === 'form' && is_array($site_id)) {
                foreach($site_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['siteId'] = $site_id;
            }
        }
        // query params
        if ($instance_id !== null) {
            if('form' === 'form' && is_array($instance_id)) {
                foreach($instance_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['instanceId'] = $instance_id;
            }
        }
        // query params
        if ($container_id !== null) {
            if('form' === 'form' && is_array($container_id)) {
                foreach($container_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['containerId'] = $container_id;
            }
        }
        // query params
        if ($server_id !== null) {
            if('form' === 'form' && is_array($server_id)) {
                foreach($server_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['serverId'] = $server_id;
            }
        }
        // query params
        if ($user_id !== null) {
            if('form' === 'form' && is_array($user_id)) {
                foreach($user_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['userId'] = $user_id;
            }
        }
        // query params
        if ($project_id !== null) {
            if('form' === 'form' && is_array($project_id)) {
                foreach($project_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['projectId'] = $project_id;
            }
        }
        // query params
        if ($active !== null) {
            if('form' === 'form' && is_array($active)) {
                foreach($active as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['active'] = $active;
            }
        }
        // query params
        if ($account_id !== null) {
            if('form' === 'form' && is_array($account_id)) {
                foreach($account_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['accountId'] = $account_id;
            }
        }
        // query params
        if ($include_line_items !== null) {
            if('form' === 'form' && is_array($include_line_items)) {
                foreach($include_line_items as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeLineItems'] = $include_line_items;
            }
        }
        // query params
        if ($include_totals !== null) {
            if('form' === 'form' && is_array($include_totals)) {
                foreach($include_totals as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeTotals'] = $include_totals;
            }
        }
        // query params
        if ($tags !== null) {
            if('form' === 'form' && is_array($tags)) {
                foreach($tags as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['tags'] = $tags;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateInvoices
     *
     * Update Invoice Tags
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     * @param  \OpenAPI\Client\Model\InlineObject102 $inline_object102 inline_object102 (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function updateInvoices($id, $inline_object102 = null)
    {
        list($response) = $this->updateInvoicesWithHttpInfo($id, $inline_object102);
        return $response;
    }

    /**
     * Operation updateInvoicesWithHttpInfo
     *
     * Update Invoice Tags
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     * @param  \OpenAPI\Client\Model\InlineObject102 $inline_object102 (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateInvoicesWithHttpInfo($id, $inline_object102 = null)
    {
        $request = $this->updateInvoicesRequest($id, $inline_object102);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateInvoicesAsync
     *
     * Update Invoice Tags
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     * @param  \OpenAPI\Client\Model\InlineObject102 $inline_object102 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInvoicesAsync($id, $inline_object102 = null)
    {
        return $this->updateInvoicesAsyncWithHttpInfo($id, $inline_object102)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateInvoicesAsyncWithHttpInfo
     *
     * Update Invoice Tags
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     * @param  \OpenAPI\Client\Model\InlineObject102 $inline_object102 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateInvoicesAsyncWithHttpInfo($id, $inline_object102 = null)
    {
        $returnType = 'object';
        $request = $this->updateInvoicesRequest($id, $inline_object102);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateInvoices'
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     * @param  \OpenAPI\Client\Model\InlineObject102 $inline_object102 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateInvoicesRequest($id, $inline_object102 = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateInvoices'
            );
        }

        $resourcePath = '/api/invoices/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($inline_object102)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($inline_object102));
            } else {
                $httpBody = $inline_object102;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
