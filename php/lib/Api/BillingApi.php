<?php
/**
 * BillingApi
 * PHP version 7.2
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Morpheus API
 *
 * Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.
 *
 * The version of the OpenAPI document: 6.2.1
 * Contact: dev@morpheusdata.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * BillingApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class BillingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation getBillingAccount
     *
     * This endpoint will retrieve a specific account by id if the user has permission to access it
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function getBillingAccount($id, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        list($response) = $this->getBillingAccountWithHttpInfo($id, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots);
        return $response;
    }

    /**
     * Operation getBillingAccountWithHttpInfo
     *
     * This endpoint will retrieve a specific account by id if the user has permission to access it
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBillingAccountWithHttpInfo($id, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        $request = $this->getBillingAccountRequest($id, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBillingAccountAsync
     *
     * This endpoint will retrieve a specific account by id if the user has permission to access it
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillingAccountAsync($id, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        return $this->getBillingAccountAsyncWithHttpInfo($id, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBillingAccountAsyncWithHttpInfo
     *
     * This endpoint will retrieve a specific account by id if the user has permission to access it
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillingAccountAsyncWithHttpInfo($id, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        $returnType = 'object';
        $request = $this->getBillingAccountRequest($id, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBillingAccount'
     *
     * @param  int $id Morpheus ID of the Object being referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBillingAccountRequest($id, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getBillingAccount'
            );
        }

        $resourcePath = '/api/billing/account/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            if('form' === 'form' && is_array($start_date)) {
                foreach($start_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startDate'] = $start_date;
            }
        }
        // query params
        if ($end_date !== null) {
            if('form' === 'form' && is_array($end_date)) {
                foreach($end_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['endDate'] = $end_date;
            }
        }
        // query params
        if ($include_usages !== null) {
            if('form' === 'form' && is_array($include_usages)) {
                foreach($include_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeUsages'] = $include_usages;
            }
        }
        // query params
        if ($max_usages !== null) {
            if('form' === 'form' && is_array($max_usages)) {
                foreach($max_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxUsages'] = $max_usages;
            }
        }
        // query params
        if ($offset_usages !== null) {
            if('form' === 'form' && is_array($offset_usages)) {
                foreach($offset_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offsetUsages'] = $offset_usages;
            }
        }
        // query params
        if ($include_compute_servers !== null) {
            if('form' === 'form' && is_array($include_compute_servers)) {
                foreach($include_compute_servers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeComputeServers'] = $include_compute_servers;
            }
        }
        // query params
        if ($include_instances !== null) {
            if('form' === 'form' && is_array($include_instances)) {
                foreach($include_instances as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeInstances'] = $include_instances;
            }
        }
        // query params
        if ($include_discovered_servers !== null) {
            if('form' === 'form' && is_array($include_discovered_servers)) {
                foreach($include_discovered_servers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeDiscoveredServers'] = $include_discovered_servers;
            }
        }
        // query params
        if ($include_load_balancers !== null) {
            if('form' === 'form' && is_array($include_load_balancers)) {
                foreach($include_load_balancers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeLoadBalancers'] = $include_load_balancers;
            }
        }
        // query params
        if ($include_virtual_images !== null) {
            if('form' === 'form' && is_array($include_virtual_images)) {
                foreach($include_virtual_images as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeVirtualImages'] = $include_virtual_images;
            }
        }
        // query params
        if ($include_snapshots !== null) {
            if('form' === 'form' && is_array($include_snapshots)) {
                foreach($include_snapshots as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeSnapshots'] = $include_snapshots;
            }
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBillingInstancesIdentifier
     *
     * Retrieves billing information for an instance in the requestor's account. Use instanceUUID whenever possible.
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function getBillingInstancesIdentifier($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        list($response) = $this->getBillingInstancesIdentifierWithHttpInfo($identifier, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id);
        return $response;
    }

    /**
     * Operation getBillingInstancesIdentifierWithHttpInfo
     *
     * Retrieves billing information for an instance in the requestor's account. Use instanceUUID whenever possible.
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBillingInstancesIdentifierWithHttpInfo($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        $request = $this->getBillingInstancesIdentifierRequest($identifier, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBillingInstancesIdentifierAsync
     *
     * Retrieves billing information for an instance in the requestor's account. Use instanceUUID whenever possible.
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillingInstancesIdentifierAsync($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        return $this->getBillingInstancesIdentifierAsyncWithHttpInfo($identifier, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBillingInstancesIdentifierAsyncWithHttpInfo
     *
     * Retrieves billing information for an instance in the requestor's account. Use instanceUUID whenever possible.
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillingInstancesIdentifierAsyncWithHttpInfo($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        $returnType = 'object';
        $request = $this->getBillingInstancesIdentifierRequest($identifier, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBillingInstancesIdentifier'
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBillingInstancesIdentifierRequest($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling getBillingInstancesIdentifier'
            );
        }

        $resourcePath = '/api/billing/instances/{identifier}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            if('form' === 'form' && is_array($start_date)) {
                foreach($start_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startDate'] = $start_date;
            }
        }
        // query params
        if ($end_date !== null) {
            if('form' === 'form' && is_array($end_date)) {
                foreach($end_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['endDate'] = $end_date;
            }
        }
        // query params
        if ($include_usages !== null) {
            if('form' === 'form' && is_array($include_usages)) {
                foreach($include_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeUsages'] = $include_usages;
            }
        }
        // query params
        if ($max_usages !== null) {
            if('form' === 'form' && is_array($max_usages)) {
                foreach($max_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxUsages'] = $max_usages;
            }
        }
        // query params
        if ($offset_usages !== null) {
            if('form' === 'form' && is_array($offset_usages)) {
                foreach($offset_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offsetUsages'] = $offset_usages;
            }
        }
        // query params
        if ($include_tenants !== null) {
            if('form' === 'form' && is_array($include_tenants)) {
                foreach($include_tenants as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeTenants'] = $include_tenants;
            }
        }
        // query params
        if ($account_id !== null) {
            if('form' === 'form' && is_array($account_id)) {
                foreach($account_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['accountId'] = $account_id;
            }
        }


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBillingServersIdentifier
     *
     * Retrieves billing information for a specific server (container host) in the requestor's account. Use refUUID whenever possible.
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function getBillingServersIdentifier($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        list($response) = $this->getBillingServersIdentifierWithHttpInfo($identifier, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id);
        return $response;
    }

    /**
     * Operation getBillingServersIdentifierWithHttpInfo
     *
     * Retrieves billing information for a specific server (container host) in the requestor's account. Use refUUID whenever possible.
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBillingServersIdentifierWithHttpInfo($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        $request = $this->getBillingServersIdentifierRequest($identifier, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBillingServersIdentifierAsync
     *
     * Retrieves billing information for a specific server (container host) in the requestor's account. Use refUUID whenever possible.
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillingServersIdentifierAsync($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        return $this->getBillingServersIdentifierAsyncWithHttpInfo($identifier, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBillingServersIdentifierAsyncWithHttpInfo
     *
     * Retrieves billing information for a specific server (container host) in the requestor's account. Use refUUID whenever possible.
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillingServersIdentifierAsyncWithHttpInfo($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        $returnType = 'object';
        $request = $this->getBillingServersIdentifierRequest($identifier, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBillingServersIdentifier'
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBillingServersIdentifierRequest($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling getBillingServersIdentifier'
            );
        }

        $resourcePath = '/api/billing/servers/{identifier}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            if('form' === 'form' && is_array($start_date)) {
                foreach($start_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startDate'] = $start_date;
            }
        }
        // query params
        if ($end_date !== null) {
            if('form' === 'form' && is_array($end_date)) {
                foreach($end_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['endDate'] = $end_date;
            }
        }
        // query params
        if ($include_usages !== null) {
            if('form' === 'form' && is_array($include_usages)) {
                foreach($include_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeUsages'] = $include_usages;
            }
        }
        // query params
        if ($max_usages !== null) {
            if('form' === 'form' && is_array($max_usages)) {
                foreach($max_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxUsages'] = $max_usages;
            }
        }
        // query params
        if ($offset_usages !== null) {
            if('form' === 'form' && is_array($offset_usages)) {
                foreach($offset_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offsetUsages'] = $offset_usages;
            }
        }
        // query params
        if ($include_tenants !== null) {
            if('form' === 'form' && is_array($include_tenants)) {
                foreach($include_tenants as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeTenants'] = $include_tenants;
            }
        }
        // query params
        if ($account_id !== null) {
            if('form' === 'form' && is_array($account_id)) {
                foreach($account_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['accountId'] = $account_id;
            }
        }


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getBillingZoneIdentifier
     *
     * Retrieves billing information for a specific zone in the requestor's account. Use zoneUUID whenever possible.
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function getBillingZoneIdentifier($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        list($response) = $this->getBillingZoneIdentifierWithHttpInfo($identifier, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots);
        return $response;
    }

    /**
     * Operation getBillingZoneIdentifierWithHttpInfo
     *
     * Retrieves billing information for a specific zone in the requestor's account. Use zoneUUID whenever possible.
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function getBillingZoneIdentifierWithHttpInfo($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        $request = $this->getBillingZoneIdentifierRequest($identifier, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getBillingZoneIdentifierAsync
     *
     * Retrieves billing information for a specific zone in the requestor's account. Use zoneUUID whenever possible.
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillingZoneIdentifierAsync($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        return $this->getBillingZoneIdentifierAsyncWithHttpInfo($identifier, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getBillingZoneIdentifierAsyncWithHttpInfo
     *
     * Retrieves billing information for a specific zone in the requestor's account. Use zoneUUID whenever possible.
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getBillingZoneIdentifierAsyncWithHttpInfo($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        $returnType = 'object';
        $request = $this->getBillingZoneIdentifierRequest($identifier, $start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getBillingZoneIdentifier'
     *
     * @param  string $identifier Morpheus UUID or ID of the Object being created or referenced (required)
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getBillingZoneIdentifierRequest($identifier, $start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        // verify the required parameter 'identifier' is set
        if ($identifier === null || (is_array($identifier) && count($identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identifier when calling getBillingZoneIdentifier'
            );
        }

        $resourcePath = '/api/billing/zones/{identifier}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            if('form' === 'form' && is_array($start_date)) {
                foreach($start_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startDate'] = $start_date;
            }
        }
        // query params
        if ($end_date !== null) {
            if('form' === 'form' && is_array($end_date)) {
                foreach($end_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['endDate'] = $end_date;
            }
        }
        // query params
        if ($include_usages !== null) {
            if('form' === 'form' && is_array($include_usages)) {
                foreach($include_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeUsages'] = $include_usages;
            }
        }
        // query params
        if ($max_usages !== null) {
            if('form' === 'form' && is_array($max_usages)) {
                foreach($max_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxUsages'] = $max_usages;
            }
        }
        // query params
        if ($offset_usages !== null) {
            if('form' === 'form' && is_array($offset_usages)) {
                foreach($offset_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offsetUsages'] = $offset_usages;
            }
        }
        // query params
        if ($include_compute_servers !== null) {
            if('form' === 'form' && is_array($include_compute_servers)) {
                foreach($include_compute_servers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeComputeServers'] = $include_compute_servers;
            }
        }
        // query params
        if ($include_instances !== null) {
            if('form' === 'form' && is_array($include_instances)) {
                foreach($include_instances as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeInstances'] = $include_instances;
            }
        }
        // query params
        if ($include_discovered_servers !== null) {
            if('form' === 'form' && is_array($include_discovered_servers)) {
                foreach($include_discovered_servers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeDiscoveredServers'] = $include_discovered_servers;
            }
        }
        // query params
        if ($include_load_balancers !== null) {
            if('form' === 'form' && is_array($include_load_balancers)) {
                foreach($include_load_balancers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeLoadBalancers'] = $include_load_balancers;
            }
        }
        // query params
        if ($include_virtual_images !== null) {
            if('form' === 'form' && is_array($include_virtual_images)) {
                foreach($include_virtual_images as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeVirtualImages'] = $include_virtual_images;
            }
        }
        // query params
        if ($include_snapshots !== null) {
            if('form' === 'form' && is_array($include_snapshots)) {
                foreach($include_snapshots as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeSnapshots'] = $include_snapshots;
            }
        }


        // path params
        if ($identifier !== null) {
            $resourcePath = str_replace(
                '{' . 'identifier' . '}',
                ObjectSerializer::toPathValue($identifier),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listBillingAccount
     *
     * Retrieves billing information for the requesting user's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function listBillingAccount($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        list($response) = $this->listBillingAccountWithHttpInfo($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots);
        return $response;
    }

    /**
     * Operation listBillingAccountWithHttpInfo
     *
     * Retrieves billing information for the requesting user's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function listBillingAccountWithHttpInfo($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        $request = $this->listBillingAccountRequest($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listBillingAccountAsync
     *
     * Retrieves billing information for the requesting user's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBillingAccountAsync($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        return $this->listBillingAccountAsyncWithHttpInfo($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listBillingAccountAsyncWithHttpInfo
     *
     * Retrieves billing information for the requesting user's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBillingAccountAsyncWithHttpInfo($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        $returnType = 'object';
        $request = $this->listBillingAccountRequest($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listBillingAccount'
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listBillingAccountRequest($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {

        $resourcePath = '/api/billing/account';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            if('form' === 'form' && is_array($start_date)) {
                foreach($start_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startDate'] = $start_date;
            }
        }
        // query params
        if ($end_date !== null) {
            if('form' === 'form' && is_array($end_date)) {
                foreach($end_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['endDate'] = $end_date;
            }
        }
        // query params
        if ($include_usages !== null) {
            if('form' === 'form' && is_array($include_usages)) {
                foreach($include_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeUsages'] = $include_usages;
            }
        }
        // query params
        if ($max_usages !== null) {
            if('form' === 'form' && is_array($max_usages)) {
                foreach($max_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxUsages'] = $max_usages;
            }
        }
        // query params
        if ($offset_usages !== null) {
            if('form' === 'form' && is_array($offset_usages)) {
                foreach($offset_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offsetUsages'] = $offset_usages;
            }
        }
        // query params
        if ($include_compute_servers !== null) {
            if('form' === 'form' && is_array($include_compute_servers)) {
                foreach($include_compute_servers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeComputeServers'] = $include_compute_servers;
            }
        }
        // query params
        if ($include_instances !== null) {
            if('form' === 'form' && is_array($include_instances)) {
                foreach($include_instances as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeInstances'] = $include_instances;
            }
        }
        // query params
        if ($include_discovered_servers !== null) {
            if('form' === 'form' && is_array($include_discovered_servers)) {
                foreach($include_discovered_servers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeDiscoveredServers'] = $include_discovered_servers;
            }
        }
        // query params
        if ($include_load_balancers !== null) {
            if('form' === 'form' && is_array($include_load_balancers)) {
                foreach($include_load_balancers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeLoadBalancers'] = $include_load_balancers;
            }
        }
        // query params
        if ($include_virtual_images !== null) {
            if('form' === 'form' && is_array($include_virtual_images)) {
                foreach($include_virtual_images as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeVirtualImages'] = $include_virtual_images;
            }
        }
        // query params
        if ($include_snapshots !== null) {
            if('form' === 'form' && is_array($include_snapshots)) {
                foreach($include_snapshots as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeSnapshots'] = $include_snapshots;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listBillingInstances
     *
     * Retrieves billing information for all instances on the requestor's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function listBillingInstances($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        list($response) = $this->listBillingInstancesWithHttpInfo($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id);
        return $response;
    }

    /**
     * Operation listBillingInstancesWithHttpInfo
     *
     * Retrieves billing information for all instances on the requestor's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function listBillingInstancesWithHttpInfo($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        $request = $this->listBillingInstancesRequest($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listBillingInstancesAsync
     *
     * Retrieves billing information for all instances on the requestor's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBillingInstancesAsync($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        return $this->listBillingInstancesAsyncWithHttpInfo($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listBillingInstancesAsyncWithHttpInfo
     *
     * Retrieves billing information for all instances on the requestor's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBillingInstancesAsyncWithHttpInfo($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        $returnType = 'object';
        $request = $this->listBillingInstancesRequest($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listBillingInstances'
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listBillingInstancesRequest($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {

        $resourcePath = '/api/billing/instances';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            if('form' === 'form' && is_array($start_date)) {
                foreach($start_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startDate'] = $start_date;
            }
        }
        // query params
        if ($end_date !== null) {
            if('form' === 'form' && is_array($end_date)) {
                foreach($end_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['endDate'] = $end_date;
            }
        }
        // query params
        if ($include_usages !== null) {
            if('form' === 'form' && is_array($include_usages)) {
                foreach($include_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeUsages'] = $include_usages;
            }
        }
        // query params
        if ($max_usages !== null) {
            if('form' === 'form' && is_array($max_usages)) {
                foreach($max_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxUsages'] = $max_usages;
            }
        }
        // query params
        if ($offset_usages !== null) {
            if('form' === 'form' && is_array($offset_usages)) {
                foreach($offset_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offsetUsages'] = $offset_usages;
            }
        }
        // query params
        if ($include_tenants !== null) {
            if('form' === 'form' && is_array($include_tenants)) {
                foreach($include_tenants as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeTenants'] = $include_tenants;
            }
        }
        // query params
        if ($account_id !== null) {
            if('form' === 'form' && is_array($account_id)) {
                foreach($account_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['accountId'] = $account_id;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listBillingServers
     *
     * Retrieves billing information for all servers (container hosts) on the requestor's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function listBillingServers($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        list($response) = $this->listBillingServersWithHttpInfo($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id);
        return $response;
    }

    /**
     * Operation listBillingServersWithHttpInfo
     *
     * Retrieves billing information for all servers (container hosts) on the requestor's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function listBillingServersWithHttpInfo($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        $request = $this->listBillingServersRequest($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listBillingServersAsync
     *
     * Retrieves billing information for all servers (container hosts) on the requestor's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBillingServersAsync($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        return $this->listBillingServersAsyncWithHttpInfo($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listBillingServersAsyncWithHttpInfo
     *
     * Retrieves billing information for all servers (container hosts) on the requestor's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBillingServersAsyncWithHttpInfo($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {
        $returnType = 'object';
        $request = $this->listBillingServersRequest($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_tenants, $account_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listBillingServers'
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_tenants Optional ability to include all subtenant billing information when calling from a master tenant user (optional, default to false)
     * @param  int $account_id Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listBillingServersRequest($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_tenants = false, $account_id = null)
    {

        $resourcePath = '/api/billing/servers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            if('form' === 'form' && is_array($start_date)) {
                foreach($start_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startDate'] = $start_date;
            }
        }
        // query params
        if ($end_date !== null) {
            if('form' === 'form' && is_array($end_date)) {
                foreach($end_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['endDate'] = $end_date;
            }
        }
        // query params
        if ($include_usages !== null) {
            if('form' === 'form' && is_array($include_usages)) {
                foreach($include_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeUsages'] = $include_usages;
            }
        }
        // query params
        if ($max_usages !== null) {
            if('form' === 'form' && is_array($max_usages)) {
                foreach($max_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxUsages'] = $max_usages;
            }
        }
        // query params
        if ($offset_usages !== null) {
            if('form' === 'form' && is_array($offset_usages)) {
                foreach($offset_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offsetUsages'] = $offset_usages;
            }
        }
        // query params
        if ($include_tenants !== null) {
            if('form' === 'form' && is_array($include_tenants)) {
                foreach($include_tenants as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeTenants'] = $include_tenants;
            }
        }
        // query params
        if ($account_id !== null) {
            if('form' === 'form' && is_array($account_id)) {
                foreach($account_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['accountId'] = $account_id;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listBillingZone
     *
     * Retrieves billing information for all zones on the requestor's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError
     */
    public function listBillingZone($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        list($response) = $this->listBillingZoneWithHttpInfo($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots);
        return $response;
    }

    /**
     * Operation listBillingZoneWithHttpInfo
     *
     * Retrieves billing information for all zones on the requestor's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\DefaultError|\OpenAPI\Client\Model\DefaultError, HTTP status code, HTTP response headers (array of strings)
     */
    public function listBillingZoneWithHttpInfo($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        $request = $this->listBillingZoneRequest($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('object' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'object', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 4XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 5XX:
                    if ('\OpenAPI\Client\Model\DefaultError' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\DefaultError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'object';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 4XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 5XX:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\DefaultError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listBillingZoneAsync
     *
     * Retrieves billing information for all zones on the requestor's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBillingZoneAsync($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        return $this->listBillingZoneAsyncWithHttpInfo($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listBillingZoneAsyncWithHttpInfo
     *
     * Retrieves billing information for all zones on the requestor's account.
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listBillingZoneAsyncWithHttpInfo($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {
        $returnType = 'object';
        $request = $this->listBillingZoneRequest($start_date, $end_date, $include_usages, $max_usages, $offset_usages, $include_compute_servers, $include_instances, $include_discovered_servers, $include_load_balancers, $include_virtual_images, $include_snapshots);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listBillingZone'
     *
     * @param  string $start_date Filter by startDate greater than or equal to a specified date (optional)
     * @param  string $end_date Filter by endDate less than or equal to a specified date (optional)
     * @param  bool $include_usages Optional ability to suppress the usage records (optional, default to true)
     * @param  int $max_usages Optional ability to limit the usages returned (optional)
     * @param  int $offset_usages Optional ability to offset the usages returned, for use with maxUsages to paginate (optional)
     * @param  bool $include_compute_servers Optional ability to exclude compute servers (optional, default to true)
     * @param  bool $include_instances Optional ability to exclude instances (optional, default to true)
     * @param  bool $include_discovered_servers Optional ability to exclude discovered servers (optional, default to true)
     * @param  bool $include_load_balancers Optional ability to exclude load balancers (optional, default to true)
     * @param  bool $include_virtual_images Optional ability to exclude virtual images (optional, default to true)
     * @param  bool $include_snapshots Optional ability to exclude snapshots (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listBillingZoneRequest($start_date = null, $end_date = null, $include_usages = true, $max_usages = null, $offset_usages = null, $include_compute_servers = true, $include_instances = true, $include_discovered_servers = true, $include_load_balancers = true, $include_virtual_images = true, $include_snapshots = true)
    {

        $resourcePath = '/api/billing/zones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($start_date !== null) {
            if('form' === 'form' && is_array($start_date)) {
                foreach($start_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['startDate'] = $start_date;
            }
        }
        // query params
        if ($end_date !== null) {
            if('form' === 'form' && is_array($end_date)) {
                foreach($end_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['endDate'] = $end_date;
            }
        }
        // query params
        if ($include_usages !== null) {
            if('form' === 'form' && is_array($include_usages)) {
                foreach($include_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeUsages'] = $include_usages;
            }
        }
        // query params
        if ($max_usages !== null) {
            if('form' === 'form' && is_array($max_usages)) {
                foreach($max_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxUsages'] = $max_usages;
            }
        }
        // query params
        if ($offset_usages !== null) {
            if('form' === 'form' && is_array($offset_usages)) {
                foreach($offset_usages as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offsetUsages'] = $offset_usages;
            }
        }
        // query params
        if ($include_compute_servers !== null) {
            if('form' === 'form' && is_array($include_compute_servers)) {
                foreach($include_compute_servers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeComputeServers'] = $include_compute_servers;
            }
        }
        // query params
        if ($include_instances !== null) {
            if('form' === 'form' && is_array($include_instances)) {
                foreach($include_instances as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeInstances'] = $include_instances;
            }
        }
        // query params
        if ($include_discovered_servers !== null) {
            if('form' === 'form' && is_array($include_discovered_servers)) {
                foreach($include_discovered_servers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeDiscoveredServers'] = $include_discovered_servers;
            }
        }
        // query params
        if ($include_load_balancers !== null) {
            if('form' === 'form' && is_array($include_load_balancers)) {
                foreach($include_load_balancers as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeLoadBalancers'] = $include_load_balancers;
            }
        }
        // query params
        if ($include_virtual_images !== null) {
            if('form' === 'form' && is_array($include_virtual_images)) {
                foreach($include_virtual_images as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeVirtualImages'] = $include_virtual_images;
            }
        }
        // query params
        if ($include_snapshots !== null) {
            if('form' === 'form' && is_array($include_snapshots)) {
                foreach($include_snapshots as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeSnapshots'] = $include_snapshots;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
