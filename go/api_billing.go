/*
 * Morpheus API
 *
 * Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.
 *
 * API version: 6.2.1
 * Contact: dev@morpheusdata.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// BillingApiService BillingApi service
type BillingApiService service

type ApiGetBillingAccountRequest struct {
	ctx _context.Context
	ApiService *BillingApiService
	id int64
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeComputeServers *bool
	includeInstances *bool
	includeDiscoveredServers *bool
	includeLoadBalancers *bool
	includeVirtualImages *bool
	includeSnapshots *bool
}

func (r ApiGetBillingAccountRequest) StartDate(startDate string) ApiGetBillingAccountRequest {
	r.startDate = &startDate
	return r
}
func (r ApiGetBillingAccountRequest) EndDate(endDate string) ApiGetBillingAccountRequest {
	r.endDate = &endDate
	return r
}
func (r ApiGetBillingAccountRequest) IncludeUsages(includeUsages bool) ApiGetBillingAccountRequest {
	r.includeUsages = &includeUsages
	return r
}
func (r ApiGetBillingAccountRequest) MaxUsages(maxUsages int64) ApiGetBillingAccountRequest {
	r.maxUsages = &maxUsages
	return r
}
func (r ApiGetBillingAccountRequest) OffsetUsages(offsetUsages int64) ApiGetBillingAccountRequest {
	r.offsetUsages = &offsetUsages
	return r
}
func (r ApiGetBillingAccountRequest) IncludeComputeServers(includeComputeServers bool) ApiGetBillingAccountRequest {
	r.includeComputeServers = &includeComputeServers
	return r
}
func (r ApiGetBillingAccountRequest) IncludeInstances(includeInstances bool) ApiGetBillingAccountRequest {
	r.includeInstances = &includeInstances
	return r
}
func (r ApiGetBillingAccountRequest) IncludeDiscoveredServers(includeDiscoveredServers bool) ApiGetBillingAccountRequest {
	r.includeDiscoveredServers = &includeDiscoveredServers
	return r
}
func (r ApiGetBillingAccountRequest) IncludeLoadBalancers(includeLoadBalancers bool) ApiGetBillingAccountRequest {
	r.includeLoadBalancers = &includeLoadBalancers
	return r
}
func (r ApiGetBillingAccountRequest) IncludeVirtualImages(includeVirtualImages bool) ApiGetBillingAccountRequest {
	r.includeVirtualImages = &includeVirtualImages
	return r
}
func (r ApiGetBillingAccountRequest) IncludeSnapshots(includeSnapshots bool) ApiGetBillingAccountRequest {
	r.includeSnapshots = &includeSnapshots
	return r
}

func (r ApiGetBillingAccountRequest) Execute() (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.GetBillingAccountExecute(r)
}

/*
 * GetBillingAccount This endpoint will retrieve a specific account by id if the user has permission to access it
 * Will retrieve billing information for a specific tenant, if it is the current account or a sub account of the requesting user's account.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id Morpheus ID of the Object being referenced
 * @return ApiGetBillingAccountRequest
 */
func (a *BillingApiService) GetBillingAccount(ctx _context.Context, id int64) ApiGetBillingAccountRequest {
	return ApiGetBillingAccountRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *BillingApiService) GetBillingAccountExecute(r ApiGetBillingAccountRequest) (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingApiService.GetBillingAccount")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/api/billing/account/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.includeUsages != nil {
		localVarQueryParams.Add("includeUsages", parameterToString(*r.includeUsages, ""))
	}
	if r.maxUsages != nil {
		localVarQueryParams.Add("maxUsages", parameterToString(*r.maxUsages, ""))
	}
	if r.offsetUsages != nil {
		localVarQueryParams.Add("offsetUsages", parameterToString(*r.offsetUsages, ""))
	}
	if r.includeComputeServers != nil {
		localVarQueryParams.Add("includeComputeServers", parameterToString(*r.includeComputeServers, ""))
	}
	if r.includeInstances != nil {
		localVarQueryParams.Add("includeInstances", parameterToString(*r.includeInstances, ""))
	}
	if r.includeDiscoveredServers != nil {
		localVarQueryParams.Add("includeDiscoveredServers", parameterToString(*r.includeDiscoveredServers, ""))
	}
	if r.includeLoadBalancers != nil {
		localVarQueryParams.Add("includeLoadBalancers", parameterToString(*r.includeLoadBalancers, ""))
	}
	if r.includeVirtualImages != nil {
		localVarQueryParams.Add("includeVirtualImages", parameterToString(*r.includeVirtualImages, ""))
	}
	if r.includeSnapshots != nil {
		localVarQueryParams.Add("includeSnapshots", parameterToString(*r.includeSnapshots, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiGetBillingInstancesIdentifierRequest struct {
	ctx _context.Context
	ApiService *BillingApiService
	identifier string
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeTenants *bool
	accountId *int64
}

func (r ApiGetBillingInstancesIdentifierRequest) StartDate(startDate string) ApiGetBillingInstancesIdentifierRequest {
	r.startDate = &startDate
	return r
}
func (r ApiGetBillingInstancesIdentifierRequest) EndDate(endDate string) ApiGetBillingInstancesIdentifierRequest {
	r.endDate = &endDate
	return r
}
func (r ApiGetBillingInstancesIdentifierRequest) IncludeUsages(includeUsages bool) ApiGetBillingInstancesIdentifierRequest {
	r.includeUsages = &includeUsages
	return r
}
func (r ApiGetBillingInstancesIdentifierRequest) MaxUsages(maxUsages int64) ApiGetBillingInstancesIdentifierRequest {
	r.maxUsages = &maxUsages
	return r
}
func (r ApiGetBillingInstancesIdentifierRequest) OffsetUsages(offsetUsages int64) ApiGetBillingInstancesIdentifierRequest {
	r.offsetUsages = &offsetUsages
	return r
}
func (r ApiGetBillingInstancesIdentifierRequest) IncludeTenants(includeTenants bool) ApiGetBillingInstancesIdentifierRequest {
	r.includeTenants = &includeTenants
	return r
}
func (r ApiGetBillingInstancesIdentifierRequest) AccountId(accountId int64) ApiGetBillingInstancesIdentifierRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetBillingInstancesIdentifierRequest) Execute() (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.GetBillingInstancesIdentifierExecute(r)
}

/*
 * GetBillingInstancesIdentifier Retrieves billing information for an instance in the requestor's account. Use instanceUUID whenever possible.
 * Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identifier Morpheus UUID or ID of the Object being created or referenced
 * @return ApiGetBillingInstancesIdentifierRequest
 */
func (a *BillingApiService) GetBillingInstancesIdentifier(ctx _context.Context, identifier string) ApiGetBillingInstancesIdentifierRequest {
	return ApiGetBillingInstancesIdentifierRequest{
		ApiService: a,
		ctx: ctx,
		identifier: identifier,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *BillingApiService) GetBillingInstancesIdentifierExecute(r ApiGetBillingInstancesIdentifierRequest) (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingApiService.GetBillingInstancesIdentifier")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/api/billing/instances/{identifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", _neturl.PathEscape(parameterToString(r.identifier, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.includeUsages != nil {
		localVarQueryParams.Add("includeUsages", parameterToString(*r.includeUsages, ""))
	}
	if r.maxUsages != nil {
		localVarQueryParams.Add("maxUsages", parameterToString(*r.maxUsages, ""))
	}
	if r.offsetUsages != nil {
		localVarQueryParams.Add("offsetUsages", parameterToString(*r.offsetUsages, ""))
	}
	if r.includeTenants != nil {
		localVarQueryParams.Add("includeTenants", parameterToString(*r.includeTenants, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiGetBillingServersIdentifierRequest struct {
	ctx _context.Context
	ApiService *BillingApiService
	identifier string
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeTenants *bool
	accountId *int64
}

func (r ApiGetBillingServersIdentifierRequest) StartDate(startDate string) ApiGetBillingServersIdentifierRequest {
	r.startDate = &startDate
	return r
}
func (r ApiGetBillingServersIdentifierRequest) EndDate(endDate string) ApiGetBillingServersIdentifierRequest {
	r.endDate = &endDate
	return r
}
func (r ApiGetBillingServersIdentifierRequest) IncludeUsages(includeUsages bool) ApiGetBillingServersIdentifierRequest {
	r.includeUsages = &includeUsages
	return r
}
func (r ApiGetBillingServersIdentifierRequest) MaxUsages(maxUsages int64) ApiGetBillingServersIdentifierRequest {
	r.maxUsages = &maxUsages
	return r
}
func (r ApiGetBillingServersIdentifierRequest) OffsetUsages(offsetUsages int64) ApiGetBillingServersIdentifierRequest {
	r.offsetUsages = &offsetUsages
	return r
}
func (r ApiGetBillingServersIdentifierRequest) IncludeTenants(includeTenants bool) ApiGetBillingServersIdentifierRequest {
	r.includeTenants = &includeTenants
	return r
}
func (r ApiGetBillingServersIdentifierRequest) AccountId(accountId int64) ApiGetBillingServersIdentifierRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetBillingServersIdentifierRequest) Execute() (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.GetBillingServersIdentifierExecute(r)
}

/*
 * GetBillingServersIdentifier Retrieves billing information for a specific server (container host) in the requestor's account. Use refUUID whenever possible.
 * Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identifier Morpheus UUID or ID of the Object being created or referenced
 * @return ApiGetBillingServersIdentifierRequest
 */
func (a *BillingApiService) GetBillingServersIdentifier(ctx _context.Context, identifier string) ApiGetBillingServersIdentifierRequest {
	return ApiGetBillingServersIdentifierRequest{
		ApiService: a,
		ctx: ctx,
		identifier: identifier,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *BillingApiService) GetBillingServersIdentifierExecute(r ApiGetBillingServersIdentifierRequest) (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingApiService.GetBillingServersIdentifier")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/api/billing/servers/{identifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", _neturl.PathEscape(parameterToString(r.identifier, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.includeUsages != nil {
		localVarQueryParams.Add("includeUsages", parameterToString(*r.includeUsages, ""))
	}
	if r.maxUsages != nil {
		localVarQueryParams.Add("maxUsages", parameterToString(*r.maxUsages, ""))
	}
	if r.offsetUsages != nil {
		localVarQueryParams.Add("offsetUsages", parameterToString(*r.offsetUsages, ""))
	}
	if r.includeTenants != nil {
		localVarQueryParams.Add("includeTenants", parameterToString(*r.includeTenants, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiGetBillingZoneIdentifierRequest struct {
	ctx _context.Context
	ApiService *BillingApiService
	identifier string
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeComputeServers *bool
	includeInstances *bool
	includeDiscoveredServers *bool
	includeLoadBalancers *bool
	includeVirtualImages *bool
	includeSnapshots *bool
}

func (r ApiGetBillingZoneIdentifierRequest) StartDate(startDate string) ApiGetBillingZoneIdentifierRequest {
	r.startDate = &startDate
	return r
}
func (r ApiGetBillingZoneIdentifierRequest) EndDate(endDate string) ApiGetBillingZoneIdentifierRequest {
	r.endDate = &endDate
	return r
}
func (r ApiGetBillingZoneIdentifierRequest) IncludeUsages(includeUsages bool) ApiGetBillingZoneIdentifierRequest {
	r.includeUsages = &includeUsages
	return r
}
func (r ApiGetBillingZoneIdentifierRequest) MaxUsages(maxUsages int64) ApiGetBillingZoneIdentifierRequest {
	r.maxUsages = &maxUsages
	return r
}
func (r ApiGetBillingZoneIdentifierRequest) OffsetUsages(offsetUsages int64) ApiGetBillingZoneIdentifierRequest {
	r.offsetUsages = &offsetUsages
	return r
}
func (r ApiGetBillingZoneIdentifierRequest) IncludeComputeServers(includeComputeServers bool) ApiGetBillingZoneIdentifierRequest {
	r.includeComputeServers = &includeComputeServers
	return r
}
func (r ApiGetBillingZoneIdentifierRequest) IncludeInstances(includeInstances bool) ApiGetBillingZoneIdentifierRequest {
	r.includeInstances = &includeInstances
	return r
}
func (r ApiGetBillingZoneIdentifierRequest) IncludeDiscoveredServers(includeDiscoveredServers bool) ApiGetBillingZoneIdentifierRequest {
	r.includeDiscoveredServers = &includeDiscoveredServers
	return r
}
func (r ApiGetBillingZoneIdentifierRequest) IncludeLoadBalancers(includeLoadBalancers bool) ApiGetBillingZoneIdentifierRequest {
	r.includeLoadBalancers = &includeLoadBalancers
	return r
}
func (r ApiGetBillingZoneIdentifierRequest) IncludeVirtualImages(includeVirtualImages bool) ApiGetBillingZoneIdentifierRequest {
	r.includeVirtualImages = &includeVirtualImages
	return r
}
func (r ApiGetBillingZoneIdentifierRequest) IncludeSnapshots(includeSnapshots bool) ApiGetBillingZoneIdentifierRequest {
	r.includeSnapshots = &includeSnapshots
	return r
}

func (r ApiGetBillingZoneIdentifierRequest) Execute() (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.GetBillingZoneIdentifierExecute(r)
}

/*
 * GetBillingZoneIdentifier Retrieves billing information for a specific zone in the requestor's account. Use zoneUUID whenever possible.
 * Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identifier Morpheus UUID or ID of the Object being created or referenced
 * @return ApiGetBillingZoneIdentifierRequest
 */
func (a *BillingApiService) GetBillingZoneIdentifier(ctx _context.Context, identifier string) ApiGetBillingZoneIdentifierRequest {
	return ApiGetBillingZoneIdentifierRequest{
		ApiService: a,
		ctx: ctx,
		identifier: identifier,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *BillingApiService) GetBillingZoneIdentifierExecute(r ApiGetBillingZoneIdentifierRequest) (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingApiService.GetBillingZoneIdentifier")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/api/billing/zones/{identifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", _neturl.PathEscape(parameterToString(r.identifier, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.includeUsages != nil {
		localVarQueryParams.Add("includeUsages", parameterToString(*r.includeUsages, ""))
	}
	if r.maxUsages != nil {
		localVarQueryParams.Add("maxUsages", parameterToString(*r.maxUsages, ""))
	}
	if r.offsetUsages != nil {
		localVarQueryParams.Add("offsetUsages", parameterToString(*r.offsetUsages, ""))
	}
	if r.includeComputeServers != nil {
		localVarQueryParams.Add("includeComputeServers", parameterToString(*r.includeComputeServers, ""))
	}
	if r.includeInstances != nil {
		localVarQueryParams.Add("includeInstances", parameterToString(*r.includeInstances, ""))
	}
	if r.includeDiscoveredServers != nil {
		localVarQueryParams.Add("includeDiscoveredServers", parameterToString(*r.includeDiscoveredServers, ""))
	}
	if r.includeLoadBalancers != nil {
		localVarQueryParams.Add("includeLoadBalancers", parameterToString(*r.includeLoadBalancers, ""))
	}
	if r.includeVirtualImages != nil {
		localVarQueryParams.Add("includeVirtualImages", parameterToString(*r.includeVirtualImages, ""))
	}
	if r.includeSnapshots != nil {
		localVarQueryParams.Add("includeSnapshots", parameterToString(*r.includeSnapshots, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiListBillingAccountRequest struct {
	ctx _context.Context
	ApiService *BillingApiService
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeComputeServers *bool
	includeInstances *bool
	includeDiscoveredServers *bool
	includeLoadBalancers *bool
	includeVirtualImages *bool
	includeSnapshots *bool
}

func (r ApiListBillingAccountRequest) StartDate(startDate string) ApiListBillingAccountRequest {
	r.startDate = &startDate
	return r
}
func (r ApiListBillingAccountRequest) EndDate(endDate string) ApiListBillingAccountRequest {
	r.endDate = &endDate
	return r
}
func (r ApiListBillingAccountRequest) IncludeUsages(includeUsages bool) ApiListBillingAccountRequest {
	r.includeUsages = &includeUsages
	return r
}
func (r ApiListBillingAccountRequest) MaxUsages(maxUsages int64) ApiListBillingAccountRequest {
	r.maxUsages = &maxUsages
	return r
}
func (r ApiListBillingAccountRequest) OffsetUsages(offsetUsages int64) ApiListBillingAccountRequest {
	r.offsetUsages = &offsetUsages
	return r
}
func (r ApiListBillingAccountRequest) IncludeComputeServers(includeComputeServers bool) ApiListBillingAccountRequest {
	r.includeComputeServers = &includeComputeServers
	return r
}
func (r ApiListBillingAccountRequest) IncludeInstances(includeInstances bool) ApiListBillingAccountRequest {
	r.includeInstances = &includeInstances
	return r
}
func (r ApiListBillingAccountRequest) IncludeDiscoveredServers(includeDiscoveredServers bool) ApiListBillingAccountRequest {
	r.includeDiscoveredServers = &includeDiscoveredServers
	return r
}
func (r ApiListBillingAccountRequest) IncludeLoadBalancers(includeLoadBalancers bool) ApiListBillingAccountRequest {
	r.includeLoadBalancers = &includeLoadBalancers
	return r
}
func (r ApiListBillingAccountRequest) IncludeVirtualImages(includeVirtualImages bool) ApiListBillingAccountRequest {
	r.includeVirtualImages = &includeVirtualImages
	return r
}
func (r ApiListBillingAccountRequest) IncludeSnapshots(includeSnapshots bool) ApiListBillingAccountRequest {
	r.includeSnapshots = &includeSnapshots
	return r
}

func (r ApiListBillingAccountRequest) Execute() (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ListBillingAccountExecute(r)
}

/*
 * ListBillingAccount Retrieves billing information for the requesting user's account.
 * Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListBillingAccountRequest
 */
func (a *BillingApiService) ListBillingAccount(ctx _context.Context) ApiListBillingAccountRequest {
	return ApiListBillingAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *BillingApiService) ListBillingAccountExecute(r ApiListBillingAccountRequest) (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingApiService.ListBillingAccount")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/api/billing/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.includeUsages != nil {
		localVarQueryParams.Add("includeUsages", parameterToString(*r.includeUsages, ""))
	}
	if r.maxUsages != nil {
		localVarQueryParams.Add("maxUsages", parameterToString(*r.maxUsages, ""))
	}
	if r.offsetUsages != nil {
		localVarQueryParams.Add("offsetUsages", parameterToString(*r.offsetUsages, ""))
	}
	if r.includeComputeServers != nil {
		localVarQueryParams.Add("includeComputeServers", parameterToString(*r.includeComputeServers, ""))
	}
	if r.includeInstances != nil {
		localVarQueryParams.Add("includeInstances", parameterToString(*r.includeInstances, ""))
	}
	if r.includeDiscoveredServers != nil {
		localVarQueryParams.Add("includeDiscoveredServers", parameterToString(*r.includeDiscoveredServers, ""))
	}
	if r.includeLoadBalancers != nil {
		localVarQueryParams.Add("includeLoadBalancers", parameterToString(*r.includeLoadBalancers, ""))
	}
	if r.includeVirtualImages != nil {
		localVarQueryParams.Add("includeVirtualImages", parameterToString(*r.includeVirtualImages, ""))
	}
	if r.includeSnapshots != nil {
		localVarQueryParams.Add("includeSnapshots", parameterToString(*r.includeSnapshots, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiListBillingInstancesRequest struct {
	ctx _context.Context
	ApiService *BillingApiService
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeTenants *bool
	accountId *int64
}

func (r ApiListBillingInstancesRequest) StartDate(startDate string) ApiListBillingInstancesRequest {
	r.startDate = &startDate
	return r
}
func (r ApiListBillingInstancesRequest) EndDate(endDate string) ApiListBillingInstancesRequest {
	r.endDate = &endDate
	return r
}
func (r ApiListBillingInstancesRequest) IncludeUsages(includeUsages bool) ApiListBillingInstancesRequest {
	r.includeUsages = &includeUsages
	return r
}
func (r ApiListBillingInstancesRequest) MaxUsages(maxUsages int64) ApiListBillingInstancesRequest {
	r.maxUsages = &maxUsages
	return r
}
func (r ApiListBillingInstancesRequest) OffsetUsages(offsetUsages int64) ApiListBillingInstancesRequest {
	r.offsetUsages = &offsetUsages
	return r
}
func (r ApiListBillingInstancesRequest) IncludeTenants(includeTenants bool) ApiListBillingInstancesRequest {
	r.includeTenants = &includeTenants
	return r
}
func (r ApiListBillingInstancesRequest) AccountId(accountId int64) ApiListBillingInstancesRequest {
	r.accountId = &accountId
	return r
}

func (r ApiListBillingInstancesRequest) Execute() (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ListBillingInstancesExecute(r)
}

/*
 * ListBillingInstances Retrieves billing information for all instances on the requestor's account.
 * Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListBillingInstancesRequest
 */
func (a *BillingApiService) ListBillingInstances(ctx _context.Context) ApiListBillingInstancesRequest {
	return ApiListBillingInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *BillingApiService) ListBillingInstancesExecute(r ApiListBillingInstancesRequest) (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingApiService.ListBillingInstances")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/api/billing/instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.includeUsages != nil {
		localVarQueryParams.Add("includeUsages", parameterToString(*r.includeUsages, ""))
	}
	if r.maxUsages != nil {
		localVarQueryParams.Add("maxUsages", parameterToString(*r.maxUsages, ""))
	}
	if r.offsetUsages != nil {
		localVarQueryParams.Add("offsetUsages", parameterToString(*r.offsetUsages, ""))
	}
	if r.includeTenants != nil {
		localVarQueryParams.Add("includeTenants", parameterToString(*r.includeTenants, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiListBillingServersRequest struct {
	ctx _context.Context
	ApiService *BillingApiService
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeTenants *bool
	accountId *int64
}

func (r ApiListBillingServersRequest) StartDate(startDate string) ApiListBillingServersRequest {
	r.startDate = &startDate
	return r
}
func (r ApiListBillingServersRequest) EndDate(endDate string) ApiListBillingServersRequest {
	r.endDate = &endDate
	return r
}
func (r ApiListBillingServersRequest) IncludeUsages(includeUsages bool) ApiListBillingServersRequest {
	r.includeUsages = &includeUsages
	return r
}
func (r ApiListBillingServersRequest) MaxUsages(maxUsages int64) ApiListBillingServersRequest {
	r.maxUsages = &maxUsages
	return r
}
func (r ApiListBillingServersRequest) OffsetUsages(offsetUsages int64) ApiListBillingServersRequest {
	r.offsetUsages = &offsetUsages
	return r
}
func (r ApiListBillingServersRequest) IncludeTenants(includeTenants bool) ApiListBillingServersRequest {
	r.includeTenants = &includeTenants
	return r
}
func (r ApiListBillingServersRequest) AccountId(accountId int64) ApiListBillingServersRequest {
	r.accountId = &accountId
	return r
}

func (r ApiListBillingServersRequest) Execute() (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ListBillingServersExecute(r)
}

/*
 * ListBillingServers Retrieves billing information for all servers (container hosts) on the requestor's account.
 * Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListBillingServersRequest
 */
func (a *BillingApiService) ListBillingServers(ctx _context.Context) ApiListBillingServersRequest {
	return ApiListBillingServersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *BillingApiService) ListBillingServersExecute(r ApiListBillingServersRequest) (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingApiService.ListBillingServers")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/api/billing/servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.includeUsages != nil {
		localVarQueryParams.Add("includeUsages", parameterToString(*r.includeUsages, ""))
	}
	if r.maxUsages != nil {
		localVarQueryParams.Add("maxUsages", parameterToString(*r.maxUsages, ""))
	}
	if r.offsetUsages != nil {
		localVarQueryParams.Add("offsetUsages", parameterToString(*r.offsetUsages, ""))
	}
	if r.includeTenants != nil {
		localVarQueryParams.Add("includeTenants", parameterToString(*r.includeTenants, ""))
	}
	if r.accountId != nil {
		localVarQueryParams.Add("accountId", parameterToString(*r.accountId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiListBillingZoneRequest struct {
	ctx _context.Context
	ApiService *BillingApiService
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeComputeServers *bool
	includeInstances *bool
	includeDiscoveredServers *bool
	includeLoadBalancers *bool
	includeVirtualImages *bool
	includeSnapshots *bool
}

func (r ApiListBillingZoneRequest) StartDate(startDate string) ApiListBillingZoneRequest {
	r.startDate = &startDate
	return r
}
func (r ApiListBillingZoneRequest) EndDate(endDate string) ApiListBillingZoneRequest {
	r.endDate = &endDate
	return r
}
func (r ApiListBillingZoneRequest) IncludeUsages(includeUsages bool) ApiListBillingZoneRequest {
	r.includeUsages = &includeUsages
	return r
}
func (r ApiListBillingZoneRequest) MaxUsages(maxUsages int64) ApiListBillingZoneRequest {
	r.maxUsages = &maxUsages
	return r
}
func (r ApiListBillingZoneRequest) OffsetUsages(offsetUsages int64) ApiListBillingZoneRequest {
	r.offsetUsages = &offsetUsages
	return r
}
func (r ApiListBillingZoneRequest) IncludeComputeServers(includeComputeServers bool) ApiListBillingZoneRequest {
	r.includeComputeServers = &includeComputeServers
	return r
}
func (r ApiListBillingZoneRequest) IncludeInstances(includeInstances bool) ApiListBillingZoneRequest {
	r.includeInstances = &includeInstances
	return r
}
func (r ApiListBillingZoneRequest) IncludeDiscoveredServers(includeDiscoveredServers bool) ApiListBillingZoneRequest {
	r.includeDiscoveredServers = &includeDiscoveredServers
	return r
}
func (r ApiListBillingZoneRequest) IncludeLoadBalancers(includeLoadBalancers bool) ApiListBillingZoneRequest {
	r.includeLoadBalancers = &includeLoadBalancers
	return r
}
func (r ApiListBillingZoneRequest) IncludeVirtualImages(includeVirtualImages bool) ApiListBillingZoneRequest {
	r.includeVirtualImages = &includeVirtualImages
	return r
}
func (r ApiListBillingZoneRequest) IncludeSnapshots(includeSnapshots bool) ApiListBillingZoneRequest {
	r.includeSnapshots = &includeSnapshots
	return r
}

func (r ApiListBillingZoneRequest) Execute() (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ListBillingZoneExecute(r)
}

/*
 * ListBillingZone Retrieves billing information for all zones on the requestor's account.
 * Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListBillingZoneRequest
 */
func (a *BillingApiService) ListBillingZone(ctx _context.Context) ApiListBillingZoneRequest {
	return ApiListBillingZoneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return map[string]interface{}
 */
func (a *BillingApiService) ListBillingZoneExecute(r ApiListBillingZoneRequest) (map[string]interface{}, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingApiService.ListBillingZone")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/api/billing/zones"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.includeUsages != nil {
		localVarQueryParams.Add("includeUsages", parameterToString(*r.includeUsages, ""))
	}
	if r.maxUsages != nil {
		localVarQueryParams.Add("maxUsages", parameterToString(*r.maxUsages, ""))
	}
	if r.offsetUsages != nil {
		localVarQueryParams.Add("offsetUsages", parameterToString(*r.offsetUsages, ""))
	}
	if r.includeComputeServers != nil {
		localVarQueryParams.Add("includeComputeServers", parameterToString(*r.includeComputeServers, ""))
	}
	if r.includeInstances != nil {
		localVarQueryParams.Add("includeInstances", parameterToString(*r.includeInstances, ""))
	}
	if r.includeDiscoveredServers != nil {
		localVarQueryParams.Add("includeDiscoveredServers", parameterToString(*r.includeDiscoveredServers, ""))
	}
	if r.includeLoadBalancers != nil {
		localVarQueryParams.Add("includeLoadBalancers", parameterToString(*r.includeLoadBalancers, ""))
	}
	if r.includeVirtualImages != nil {
		localVarQueryParams.Add("includeVirtualImages", parameterToString(*r.includeVirtualImages, ""))
	}
	if r.includeSnapshots != nil {
		localVarQueryParams.Add("includeSnapshots", parameterToString(*r.includeSnapshots, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}
