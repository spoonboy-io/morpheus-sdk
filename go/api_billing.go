/*
Morpheus API

Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.

API version: 6.1.1
Contact: dev@morpheusdata.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BillingAPIService BillingAPI service
type BillingAPIService service

type ApiGetBillingAccountRequest struct {
	ctx context.Context
	ApiService *BillingAPIService
	id int64
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeComputeServers *bool
	includeInstances *bool
	includeDiscoveredServers *bool
	includeLoadBalancers *bool
	includeVirtualImages *bool
	includeSnapshots *bool
}

// Filter by startDate greater than or equal to a specified date
func (r ApiGetBillingAccountRequest) StartDate(startDate string) ApiGetBillingAccountRequest {
	r.startDate = &startDate
	return r
}

// Filter by endDate less than or equal to a specified date
func (r ApiGetBillingAccountRequest) EndDate(endDate string) ApiGetBillingAccountRequest {
	r.endDate = &endDate
	return r
}

// Optional ability to suppress the usage records
func (r ApiGetBillingAccountRequest) IncludeUsages(includeUsages bool) ApiGetBillingAccountRequest {
	r.includeUsages = &includeUsages
	return r
}

// Optional ability to limit the usages returned
func (r ApiGetBillingAccountRequest) MaxUsages(maxUsages int64) ApiGetBillingAccountRequest {
	r.maxUsages = &maxUsages
	return r
}

// Optional ability to offset the usages returned, for use with maxUsages to paginate
func (r ApiGetBillingAccountRequest) OffsetUsages(offsetUsages int64) ApiGetBillingAccountRequest {
	r.offsetUsages = &offsetUsages
	return r
}

// Optional ability to exclude compute servers
func (r ApiGetBillingAccountRequest) IncludeComputeServers(includeComputeServers bool) ApiGetBillingAccountRequest {
	r.includeComputeServers = &includeComputeServers
	return r
}

// Optional ability to exclude instances
func (r ApiGetBillingAccountRequest) IncludeInstances(includeInstances bool) ApiGetBillingAccountRequest {
	r.includeInstances = &includeInstances
	return r
}

// Optional ability to exclude discovered servers
func (r ApiGetBillingAccountRequest) IncludeDiscoveredServers(includeDiscoveredServers bool) ApiGetBillingAccountRequest {
	r.includeDiscoveredServers = &includeDiscoveredServers
	return r
}

// Optional ability to exclude load balancers
func (r ApiGetBillingAccountRequest) IncludeLoadBalancers(includeLoadBalancers bool) ApiGetBillingAccountRequest {
	r.includeLoadBalancers = &includeLoadBalancers
	return r
}

// Optional ability to exclude virtual images
func (r ApiGetBillingAccountRequest) IncludeVirtualImages(includeVirtualImages bool) ApiGetBillingAccountRequest {
	r.includeVirtualImages = &includeVirtualImages
	return r
}

// Optional ability to exclude snapshots
func (r ApiGetBillingAccountRequest) IncludeSnapshots(includeSnapshots bool) ApiGetBillingAccountRequest {
	r.includeSnapshots = &includeSnapshots
	return r
}

func (r ApiGetBillingAccountRequest) Execute() (*ListBillingAccount200Response, *http.Response, error) {
	return r.ApiService.GetBillingAccountExecute(r)
}

/*
GetBillingAccount This endpoint will retrieve a specific account by id if the user has permission to access it

Will retrieve billing information for a specific tenant, if it is the current account or a sub account of the requesting user's account.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id Morpheus ID of the Object being referenced
 @return ApiGetBillingAccountRequest
*/
func (a *BillingAPIService) GetBillingAccount(ctx context.Context, id int64) ApiGetBillingAccountRequest {
	return ApiGetBillingAccountRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ListBillingAccount200Response
func (a *BillingAPIService) GetBillingAccountExecute(r ApiGetBillingAccountRequest) (*ListBillingAccount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListBillingAccount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.GetBillingAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/billing/account/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUsages", r.includeUsages, "")
	}
	if r.maxUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxUsages", r.maxUsages, "")
	}
	if r.offsetUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetUsages", r.offsetUsages, "")
	}
	if r.includeComputeServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeComputeServers", r.includeComputeServers, "")
	}
	if r.includeInstances != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInstances", r.includeInstances, "")
	}
	if r.includeDiscoveredServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDiscoveredServers", r.includeDiscoveredServers, "")
	}
	if r.includeLoadBalancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLoadBalancers", r.includeLoadBalancers, "")
	}
	if r.includeVirtualImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeVirtualImages", r.includeVirtualImages, "")
	}
	if r.includeSnapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSnapshots", r.includeSnapshots, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBillingInstancesIdentifierRequest struct {
	ctx context.Context
	ApiService *BillingAPIService
	identifier string
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeTenants *bool
	accountId *int64
}

// Filter by startDate greater than or equal to a specified date
func (r ApiGetBillingInstancesIdentifierRequest) StartDate(startDate string) ApiGetBillingInstancesIdentifierRequest {
	r.startDate = &startDate
	return r
}

// Filter by endDate less than or equal to a specified date
func (r ApiGetBillingInstancesIdentifierRequest) EndDate(endDate string) ApiGetBillingInstancesIdentifierRequest {
	r.endDate = &endDate
	return r
}

// Optional ability to suppress the usage records
func (r ApiGetBillingInstancesIdentifierRequest) IncludeUsages(includeUsages bool) ApiGetBillingInstancesIdentifierRequest {
	r.includeUsages = &includeUsages
	return r
}

// Optional ability to limit the usages returned
func (r ApiGetBillingInstancesIdentifierRequest) MaxUsages(maxUsages int64) ApiGetBillingInstancesIdentifierRequest {
	r.maxUsages = &maxUsages
	return r
}

// Optional ability to offset the usages returned, for use with maxUsages to paginate
func (r ApiGetBillingInstancesIdentifierRequest) OffsetUsages(offsetUsages int64) ApiGetBillingInstancesIdentifierRequest {
	r.offsetUsages = &offsetUsages
	return r
}

// Optional ability to include all subtenant billing information when calling from a master tenant user
func (r ApiGetBillingInstancesIdentifierRequest) IncludeTenants(includeTenants bool) ApiGetBillingInstancesIdentifierRequest {
	r.includeTenants = &includeTenants
	return r
}

// Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users.
func (r ApiGetBillingInstancesIdentifierRequest) AccountId(accountId int64) ApiGetBillingInstancesIdentifierRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetBillingInstancesIdentifierRequest) Execute() (*GetBillingInstancesIdentifier200Response, *http.Response, error) {
	return r.ApiService.GetBillingInstancesIdentifierExecute(r)
}

/*
GetBillingInstancesIdentifier Retrieves billing information for an instance in the requestor's account. Use instanceUUID whenever possible.

Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param identifier Morpheus UUID or ID of the Object being created or referenced
 @return ApiGetBillingInstancesIdentifierRequest
*/
func (a *BillingAPIService) GetBillingInstancesIdentifier(ctx context.Context, identifier string) ApiGetBillingInstancesIdentifierRequest {
	return ApiGetBillingInstancesIdentifierRequest{
		ApiService: a,
		ctx: ctx,
		identifier: identifier,
	}
}

// Execute executes the request
//  @return GetBillingInstancesIdentifier200Response
func (a *BillingAPIService) GetBillingInstancesIdentifierExecute(r ApiGetBillingInstancesIdentifierRequest) (*GetBillingInstancesIdentifier200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBillingInstancesIdentifier200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.GetBillingInstancesIdentifier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/billing/instances/{identifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", url.PathEscape(parameterValueToString(r.identifier, "identifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUsages", r.includeUsages, "")
	}
	if r.maxUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxUsages", r.maxUsages, "")
	}
	if r.offsetUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetUsages", r.offsetUsages, "")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBillingServersIdentifierRequest struct {
	ctx context.Context
	ApiService *BillingAPIService
	identifier string
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeTenants *bool
	accountId *int64
}

// Filter by startDate greater than or equal to a specified date
func (r ApiGetBillingServersIdentifierRequest) StartDate(startDate string) ApiGetBillingServersIdentifierRequest {
	r.startDate = &startDate
	return r
}

// Filter by endDate less than or equal to a specified date
func (r ApiGetBillingServersIdentifierRequest) EndDate(endDate string) ApiGetBillingServersIdentifierRequest {
	r.endDate = &endDate
	return r
}

// Optional ability to suppress the usage records
func (r ApiGetBillingServersIdentifierRequest) IncludeUsages(includeUsages bool) ApiGetBillingServersIdentifierRequest {
	r.includeUsages = &includeUsages
	return r
}

// Optional ability to limit the usages returned
func (r ApiGetBillingServersIdentifierRequest) MaxUsages(maxUsages int64) ApiGetBillingServersIdentifierRequest {
	r.maxUsages = &maxUsages
	return r
}

// Optional ability to offset the usages returned, for use with maxUsages to paginate
func (r ApiGetBillingServersIdentifierRequest) OffsetUsages(offsetUsages int64) ApiGetBillingServersIdentifierRequest {
	r.offsetUsages = &offsetUsages
	return r
}

// Optional ability to include all subtenant billing information when calling from a master tenant user
func (r ApiGetBillingServersIdentifierRequest) IncludeTenants(includeTenants bool) ApiGetBillingServersIdentifierRequest {
	r.includeTenants = &includeTenants
	return r
}

// Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users.
func (r ApiGetBillingServersIdentifierRequest) AccountId(accountId int64) ApiGetBillingServersIdentifierRequest {
	r.accountId = &accountId
	return r
}

func (r ApiGetBillingServersIdentifierRequest) Execute() (*GetBillingServersIdentifier200Response, *http.Response, error) {
	return r.ApiService.GetBillingServersIdentifierExecute(r)
}

/*
GetBillingServersIdentifier Retrieves billing information for a specific server (container host) in the requestor's account. Use refUUID whenever possible.

Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param identifier Morpheus UUID or ID of the Object being created or referenced
 @return ApiGetBillingServersIdentifierRequest
*/
func (a *BillingAPIService) GetBillingServersIdentifier(ctx context.Context, identifier string) ApiGetBillingServersIdentifierRequest {
	return ApiGetBillingServersIdentifierRequest{
		ApiService: a,
		ctx: ctx,
		identifier: identifier,
	}
}

// Execute executes the request
//  @return GetBillingServersIdentifier200Response
func (a *BillingAPIService) GetBillingServersIdentifierExecute(r ApiGetBillingServersIdentifierRequest) (*GetBillingServersIdentifier200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBillingServersIdentifier200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.GetBillingServersIdentifier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/billing/servers/{identifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", url.PathEscape(parameterValueToString(r.identifier, "identifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUsages", r.includeUsages, "")
	}
	if r.maxUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxUsages", r.maxUsages, "")
	}
	if r.offsetUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetUsages", r.offsetUsages, "")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBillingZoneIdentifierRequest struct {
	ctx context.Context
	ApiService *BillingAPIService
	identifier string
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeComputeServers *bool
	includeInstances *bool
	includeDiscoveredServers *bool
	includeLoadBalancers *bool
	includeVirtualImages *bool
	includeSnapshots *bool
}

// Filter by startDate greater than or equal to a specified date
func (r ApiGetBillingZoneIdentifierRequest) StartDate(startDate string) ApiGetBillingZoneIdentifierRequest {
	r.startDate = &startDate
	return r
}

// Filter by endDate less than or equal to a specified date
func (r ApiGetBillingZoneIdentifierRequest) EndDate(endDate string) ApiGetBillingZoneIdentifierRequest {
	r.endDate = &endDate
	return r
}

// Optional ability to suppress the usage records
func (r ApiGetBillingZoneIdentifierRequest) IncludeUsages(includeUsages bool) ApiGetBillingZoneIdentifierRequest {
	r.includeUsages = &includeUsages
	return r
}

// Optional ability to limit the usages returned
func (r ApiGetBillingZoneIdentifierRequest) MaxUsages(maxUsages int64) ApiGetBillingZoneIdentifierRequest {
	r.maxUsages = &maxUsages
	return r
}

// Optional ability to offset the usages returned, for use with maxUsages to paginate
func (r ApiGetBillingZoneIdentifierRequest) OffsetUsages(offsetUsages int64) ApiGetBillingZoneIdentifierRequest {
	r.offsetUsages = &offsetUsages
	return r
}

// Optional ability to exclude compute servers
func (r ApiGetBillingZoneIdentifierRequest) IncludeComputeServers(includeComputeServers bool) ApiGetBillingZoneIdentifierRequest {
	r.includeComputeServers = &includeComputeServers
	return r
}

// Optional ability to exclude instances
func (r ApiGetBillingZoneIdentifierRequest) IncludeInstances(includeInstances bool) ApiGetBillingZoneIdentifierRequest {
	r.includeInstances = &includeInstances
	return r
}

// Optional ability to exclude discovered servers
func (r ApiGetBillingZoneIdentifierRequest) IncludeDiscoveredServers(includeDiscoveredServers bool) ApiGetBillingZoneIdentifierRequest {
	r.includeDiscoveredServers = &includeDiscoveredServers
	return r
}

// Optional ability to exclude load balancers
func (r ApiGetBillingZoneIdentifierRequest) IncludeLoadBalancers(includeLoadBalancers bool) ApiGetBillingZoneIdentifierRequest {
	r.includeLoadBalancers = &includeLoadBalancers
	return r
}

// Optional ability to exclude virtual images
func (r ApiGetBillingZoneIdentifierRequest) IncludeVirtualImages(includeVirtualImages bool) ApiGetBillingZoneIdentifierRequest {
	r.includeVirtualImages = &includeVirtualImages
	return r
}

// Optional ability to exclude snapshots
func (r ApiGetBillingZoneIdentifierRequest) IncludeSnapshots(includeSnapshots bool) ApiGetBillingZoneIdentifierRequest {
	r.includeSnapshots = &includeSnapshots
	return r
}

func (r ApiGetBillingZoneIdentifierRequest) Execute() (*GetBillingZoneIdentifier200Response, *http.Response, error) {
	return r.ApiService.GetBillingZoneIdentifierExecute(r)
}

/*
GetBillingZoneIdentifier Retrieves billing information for a specific zone in the requestor's account. Use zoneUUID whenever possible.

Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param identifier Morpheus UUID or ID of the Object being created or referenced
 @return ApiGetBillingZoneIdentifierRequest
*/
func (a *BillingAPIService) GetBillingZoneIdentifier(ctx context.Context, identifier string) ApiGetBillingZoneIdentifierRequest {
	return ApiGetBillingZoneIdentifierRequest{
		ApiService: a,
		ctx: ctx,
		identifier: identifier,
	}
}

// Execute executes the request
//  @return GetBillingZoneIdentifier200Response
func (a *BillingAPIService) GetBillingZoneIdentifierExecute(r ApiGetBillingZoneIdentifierRequest) (*GetBillingZoneIdentifier200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBillingZoneIdentifier200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.GetBillingZoneIdentifier")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/billing/zones/{identifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", url.PathEscape(parameterValueToString(r.identifier, "identifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUsages", r.includeUsages, "")
	}
	if r.maxUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxUsages", r.maxUsages, "")
	}
	if r.offsetUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetUsages", r.offsetUsages, "")
	}
	if r.includeComputeServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeComputeServers", r.includeComputeServers, "")
	}
	if r.includeInstances != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInstances", r.includeInstances, "")
	}
	if r.includeDiscoveredServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDiscoveredServers", r.includeDiscoveredServers, "")
	}
	if r.includeLoadBalancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLoadBalancers", r.includeLoadBalancers, "")
	}
	if r.includeVirtualImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeVirtualImages", r.includeVirtualImages, "")
	}
	if r.includeSnapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSnapshots", r.includeSnapshots, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingAccountRequest struct {
	ctx context.Context
	ApiService *BillingAPIService
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeComputeServers *bool
	includeInstances *bool
	includeDiscoveredServers *bool
	includeLoadBalancers *bool
	includeVirtualImages *bool
	includeSnapshots *bool
}

// Filter by startDate greater than or equal to a specified date
func (r ApiListBillingAccountRequest) StartDate(startDate string) ApiListBillingAccountRequest {
	r.startDate = &startDate
	return r
}

// Filter by endDate less than or equal to a specified date
func (r ApiListBillingAccountRequest) EndDate(endDate string) ApiListBillingAccountRequest {
	r.endDate = &endDate
	return r
}

// Optional ability to suppress the usage records
func (r ApiListBillingAccountRequest) IncludeUsages(includeUsages bool) ApiListBillingAccountRequest {
	r.includeUsages = &includeUsages
	return r
}

// Optional ability to limit the usages returned
func (r ApiListBillingAccountRequest) MaxUsages(maxUsages int64) ApiListBillingAccountRequest {
	r.maxUsages = &maxUsages
	return r
}

// Optional ability to offset the usages returned, for use with maxUsages to paginate
func (r ApiListBillingAccountRequest) OffsetUsages(offsetUsages int64) ApiListBillingAccountRequest {
	r.offsetUsages = &offsetUsages
	return r
}

// Optional ability to exclude compute servers
func (r ApiListBillingAccountRequest) IncludeComputeServers(includeComputeServers bool) ApiListBillingAccountRequest {
	r.includeComputeServers = &includeComputeServers
	return r
}

// Optional ability to exclude instances
func (r ApiListBillingAccountRequest) IncludeInstances(includeInstances bool) ApiListBillingAccountRequest {
	r.includeInstances = &includeInstances
	return r
}

// Optional ability to exclude discovered servers
func (r ApiListBillingAccountRequest) IncludeDiscoveredServers(includeDiscoveredServers bool) ApiListBillingAccountRequest {
	r.includeDiscoveredServers = &includeDiscoveredServers
	return r
}

// Optional ability to exclude load balancers
func (r ApiListBillingAccountRequest) IncludeLoadBalancers(includeLoadBalancers bool) ApiListBillingAccountRequest {
	r.includeLoadBalancers = &includeLoadBalancers
	return r
}

// Optional ability to exclude virtual images
func (r ApiListBillingAccountRequest) IncludeVirtualImages(includeVirtualImages bool) ApiListBillingAccountRequest {
	r.includeVirtualImages = &includeVirtualImages
	return r
}

// Optional ability to exclude snapshots
func (r ApiListBillingAccountRequest) IncludeSnapshots(includeSnapshots bool) ApiListBillingAccountRequest {
	r.includeSnapshots = &includeSnapshots
	return r
}

func (r ApiListBillingAccountRequest) Execute() (*ListBillingAccount200Response, *http.Response, error) {
	return r.ApiService.ListBillingAccountExecute(r)
}

/*
ListBillingAccount Retrieves billing information for the requesting user's account.

Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingAccountRequest
*/
func (a *BillingAPIService) ListBillingAccount(ctx context.Context) ApiListBillingAccountRequest {
	return ApiListBillingAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListBillingAccount200Response
func (a *BillingAPIService) ListBillingAccountExecute(r ApiListBillingAccountRequest) (*ListBillingAccount200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListBillingAccount200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.ListBillingAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/billing/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUsages", r.includeUsages, "")
	}
	if r.maxUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxUsages", r.maxUsages, "")
	}
	if r.offsetUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetUsages", r.offsetUsages, "")
	}
	if r.includeComputeServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeComputeServers", r.includeComputeServers, "")
	}
	if r.includeInstances != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInstances", r.includeInstances, "")
	}
	if r.includeDiscoveredServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDiscoveredServers", r.includeDiscoveredServers, "")
	}
	if r.includeLoadBalancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLoadBalancers", r.includeLoadBalancers, "")
	}
	if r.includeVirtualImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeVirtualImages", r.includeVirtualImages, "")
	}
	if r.includeSnapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSnapshots", r.includeSnapshots, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingInstancesRequest struct {
	ctx context.Context
	ApiService *BillingAPIService
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeTenants *bool
	accountId *int64
}

// Filter by startDate greater than or equal to a specified date
func (r ApiListBillingInstancesRequest) StartDate(startDate string) ApiListBillingInstancesRequest {
	r.startDate = &startDate
	return r
}

// Filter by endDate less than or equal to a specified date
func (r ApiListBillingInstancesRequest) EndDate(endDate string) ApiListBillingInstancesRequest {
	r.endDate = &endDate
	return r
}

// Optional ability to suppress the usage records
func (r ApiListBillingInstancesRequest) IncludeUsages(includeUsages bool) ApiListBillingInstancesRequest {
	r.includeUsages = &includeUsages
	return r
}

// Optional ability to limit the usages returned
func (r ApiListBillingInstancesRequest) MaxUsages(maxUsages int64) ApiListBillingInstancesRequest {
	r.maxUsages = &maxUsages
	return r
}

// Optional ability to offset the usages returned, for use with maxUsages to paginate
func (r ApiListBillingInstancesRequest) OffsetUsages(offsetUsages int64) ApiListBillingInstancesRequest {
	r.offsetUsages = &offsetUsages
	return r
}

// Optional ability to include all subtenant billing information when calling from a master tenant user
func (r ApiListBillingInstancesRequest) IncludeTenants(includeTenants bool) ApiListBillingInstancesRequest {
	r.includeTenants = &includeTenants
	return r
}

// Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users.
func (r ApiListBillingInstancesRequest) AccountId(accountId int64) ApiListBillingInstancesRequest {
	r.accountId = &accountId
	return r
}

func (r ApiListBillingInstancesRequest) Execute() (*ListBillingInstances200Response, *http.Response, error) {
	return r.ApiService.ListBillingInstancesExecute(r)
}

/*
ListBillingInstances Retrieves billing information for all instances on the requestor's account.

Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingInstancesRequest
*/
func (a *BillingAPIService) ListBillingInstances(ctx context.Context) ApiListBillingInstancesRequest {
	return ApiListBillingInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListBillingInstances200Response
func (a *BillingAPIService) ListBillingInstancesExecute(r ApiListBillingInstancesRequest) (*ListBillingInstances200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListBillingInstances200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.ListBillingInstances")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/billing/instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUsages", r.includeUsages, "")
	}
	if r.maxUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxUsages", r.maxUsages, "")
	}
	if r.offsetUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetUsages", r.offsetUsages, "")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingServersRequest struct {
	ctx context.Context
	ApiService *BillingAPIService
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeTenants *bool
	accountId *int64
}

// Filter by startDate greater than or equal to a specified date
func (r ApiListBillingServersRequest) StartDate(startDate string) ApiListBillingServersRequest {
	r.startDate = &startDate
	return r
}

// Filter by endDate less than or equal to a specified date
func (r ApiListBillingServersRequest) EndDate(endDate string) ApiListBillingServersRequest {
	r.endDate = &endDate
	return r
}

// Optional ability to suppress the usage records
func (r ApiListBillingServersRequest) IncludeUsages(includeUsages bool) ApiListBillingServersRequest {
	r.includeUsages = &includeUsages
	return r
}

// Optional ability to limit the usages returned
func (r ApiListBillingServersRequest) MaxUsages(maxUsages int64) ApiListBillingServersRequest {
	r.maxUsages = &maxUsages
	return r
}

// Optional ability to offset the usages returned, for use with maxUsages to paginate
func (r ApiListBillingServersRequest) OffsetUsages(offsetUsages int64) ApiListBillingServersRequest {
	r.offsetUsages = &offsetUsages
	return r
}

// Optional ability to include all subtenant billing information when calling from a master tenant user
func (r ApiListBillingServersRequest) IncludeTenants(includeTenants bool) ApiListBillingServersRequest {
	r.includeTenants = &includeTenants
	return r
}

// Filter by Tenant ID. This is only available to master tenant users with permission to manage tenants and users.
func (r ApiListBillingServersRequest) AccountId(accountId int64) ApiListBillingServersRequest {
	r.accountId = &accountId
	return r
}

func (r ApiListBillingServersRequest) Execute() (*ListBillingServers200Response, *http.Response, error) {
	return r.ApiService.ListBillingServersExecute(r)
}

/*
ListBillingServers Retrieves billing information for all servers (container hosts) on the requestor's account.

Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingServersRequest
*/
func (a *BillingAPIService) ListBillingServers(ctx context.Context) ApiListBillingServersRequest {
	return ApiListBillingServersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListBillingServers200Response
func (a *BillingAPIService) ListBillingServersExecute(r ApiListBillingServersRequest) (*ListBillingServers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListBillingServers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.ListBillingServers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/billing/servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUsages", r.includeUsages, "")
	}
	if r.maxUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxUsages", r.maxUsages, "")
	}
	if r.offsetUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetUsages", r.offsetUsages, "")
	}
	if r.includeTenants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeTenants", r.includeTenants, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "accountId", r.accountId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBillingZoneRequest struct {
	ctx context.Context
	ApiService *BillingAPIService
	startDate *string
	endDate *string
	includeUsages *bool
	maxUsages *int64
	offsetUsages *int64
	includeComputeServers *bool
	includeInstances *bool
	includeDiscoveredServers *bool
	includeLoadBalancers *bool
	includeVirtualImages *bool
	includeSnapshots *bool
}

// Filter by startDate greater than or equal to a specified date
func (r ApiListBillingZoneRequest) StartDate(startDate string) ApiListBillingZoneRequest {
	r.startDate = &startDate
	return r
}

// Filter by endDate less than or equal to a specified date
func (r ApiListBillingZoneRequest) EndDate(endDate string) ApiListBillingZoneRequest {
	r.endDate = &endDate
	return r
}

// Optional ability to suppress the usage records
func (r ApiListBillingZoneRequest) IncludeUsages(includeUsages bool) ApiListBillingZoneRequest {
	r.includeUsages = &includeUsages
	return r
}

// Optional ability to limit the usages returned
func (r ApiListBillingZoneRequest) MaxUsages(maxUsages int64) ApiListBillingZoneRequest {
	r.maxUsages = &maxUsages
	return r
}

// Optional ability to offset the usages returned, for use with maxUsages to paginate
func (r ApiListBillingZoneRequest) OffsetUsages(offsetUsages int64) ApiListBillingZoneRequest {
	r.offsetUsages = &offsetUsages
	return r
}

// Optional ability to exclude compute servers
func (r ApiListBillingZoneRequest) IncludeComputeServers(includeComputeServers bool) ApiListBillingZoneRequest {
	r.includeComputeServers = &includeComputeServers
	return r
}

// Optional ability to exclude instances
func (r ApiListBillingZoneRequest) IncludeInstances(includeInstances bool) ApiListBillingZoneRequest {
	r.includeInstances = &includeInstances
	return r
}

// Optional ability to exclude discovered servers
func (r ApiListBillingZoneRequest) IncludeDiscoveredServers(includeDiscoveredServers bool) ApiListBillingZoneRequest {
	r.includeDiscoveredServers = &includeDiscoveredServers
	return r
}

// Optional ability to exclude load balancers
func (r ApiListBillingZoneRequest) IncludeLoadBalancers(includeLoadBalancers bool) ApiListBillingZoneRequest {
	r.includeLoadBalancers = &includeLoadBalancers
	return r
}

// Optional ability to exclude virtual images
func (r ApiListBillingZoneRequest) IncludeVirtualImages(includeVirtualImages bool) ApiListBillingZoneRequest {
	r.includeVirtualImages = &includeVirtualImages
	return r
}

// Optional ability to exclude snapshots
func (r ApiListBillingZoneRequest) IncludeSnapshots(includeSnapshots bool) ApiListBillingZoneRequest {
	r.includeSnapshots = &includeSnapshots
	return r
}

func (r ApiListBillingZoneRequest) Execute() (*ListBillingZone200Response, *http.Response, error) {
	return r.ApiService.ListBillingZoneExecute(r)
}

/*
ListBillingZone Retrieves billing information for all zones on the requestor's account.

Provides API interfaces for viewing billing usage information by tenant, zone, instance or server.
By default, usage returned is from the beginning of the current month until now.
The date range is parameterized but the end date cannot exceed the current date.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBillingZoneRequest
*/
func (a *BillingAPIService) ListBillingZone(ctx context.Context) ApiListBillingZoneRequest {
	return ApiListBillingZoneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListBillingZone200Response
func (a *BillingAPIService) ListBillingZoneExecute(r ApiListBillingZoneRequest) (*ListBillingZone200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListBillingZone200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.ListBillingZone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/billing/zones"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.startDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startDate", r.startDate, "")
	}
	if r.endDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endDate", r.endDate, "")
	}
	if r.includeUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeUsages", r.includeUsages, "")
	}
	if r.maxUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxUsages", r.maxUsages, "")
	}
	if r.offsetUsages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetUsages", r.offsetUsages, "")
	}
	if r.includeComputeServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeComputeServers", r.includeComputeServers, "")
	}
	if r.includeInstances != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeInstances", r.includeInstances, "")
	}
	if r.includeDiscoveredServers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeDiscoveredServers", r.includeDiscoveredServers, "")
	}
	if r.includeLoadBalancers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeLoadBalancers", r.includeLoadBalancers, "")
	}
	if r.includeVirtualImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeVirtualImages", r.includeVirtualImages, "")
	}
	if r.includeSnapshots != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeSnapshots", r.includeSnapshots, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
