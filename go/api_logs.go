/*
 * Morpheus API
 *
 * Morpheus is a powerful cloud management tool that provides provisioning, monitoring, logging, backups, and application deployment strategies.  This document describes the Morpheus API protocol and the available endpoints. Sections are organized in the same manner as they appear in the Morpheus UI.
 *
 * API version: 6.2.1
 * Contact: dev@morpheusdata.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"time"
)

// Linger please
var (
	_ _context.Context
)

// LogsApiService LogsApi service
type LogsApiService service

type ApiListLogsRequest struct {
	ctx _context.Context
	ApiService *LogsApiService
	max *int64
	offset *int64
	sort *string
	order *string
	query *string
	message *string
	sourceType *string
	typeCode *string
	objectId *int64
	token *string
	level *string
	startMs *int64
	endMs *int64
	startDateTime *time.Time
	endDateTime *time.Time
	containers *int64
	servers *int64
	clusterId *int64
}

func (r ApiListLogsRequest) Max(max int64) ApiListLogsRequest {
	r.max = &max
	return r
}
func (r ApiListLogsRequest) Offset(offset int64) ApiListLogsRequest {
	r.offset = &offset
	return r
}
func (r ApiListLogsRequest) Sort(sort string) ApiListLogsRequest {
	r.sort = &sort
	return r
}
func (r ApiListLogsRequest) Order(order string) ApiListLogsRequest {
	r.order = &order
	return r
}
func (r ApiListLogsRequest) Query(query string) ApiListLogsRequest {
	r.query = &query
	return r
}
func (r ApiListLogsRequest) Message(message string) ApiListLogsRequest {
	r.message = &message
	return r
}
func (r ApiListLogsRequest) SourceType(sourceType string) ApiListLogsRequest {
	r.sourceType = &sourceType
	return r
}
func (r ApiListLogsRequest) TypeCode(typeCode string) ApiListLogsRequest {
	r.typeCode = &typeCode
	return r
}
func (r ApiListLogsRequest) ObjectId(objectId int64) ApiListLogsRequest {
	r.objectId = &objectId
	return r
}
func (r ApiListLogsRequest) Token(token string) ApiListLogsRequest {
	r.token = &token
	return r
}
func (r ApiListLogsRequest) Level(level string) ApiListLogsRequest {
	r.level = &level
	return r
}
func (r ApiListLogsRequest) StartMs(startMs int64) ApiListLogsRequest {
	r.startMs = &startMs
	return r
}
func (r ApiListLogsRequest) EndMs(endMs int64) ApiListLogsRequest {
	r.endMs = &endMs
	return r
}
func (r ApiListLogsRequest) StartDateTime(startDateTime time.Time) ApiListLogsRequest {
	r.startDateTime = &startDateTime
	return r
}
func (r ApiListLogsRequest) EndDateTime(endDateTime time.Time) ApiListLogsRequest {
	r.endDateTime = &endDateTime
	return r
}
func (r ApiListLogsRequest) Containers(containers int64) ApiListLogsRequest {
	r.containers = &containers
	return r
}
func (r ApiListLogsRequest) Servers(servers int64) ApiListLogsRequest {
	r.servers = &servers
	return r
}
func (r ApiListLogsRequest) ClusterId(clusterId int64) ApiListLogsRequest {
	r.clusterId = &clusterId
	return r
}

func (r ApiListLogsRequest) Execute() (Log, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ListLogsExecute(r)
}

/*
 * ListLogs Retrieves Logs
 * Retrieves logs based on filters provided.

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiListLogsRequest
 */
func (a *LogsApiService) ListLogs(ctx _context.Context) ApiListLogsRequest {
	return ApiListLogsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return Log
 */
func (a *LogsApiService) ListLogsExecute(r ApiListLogsRequest) (Log, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  Log
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LogsApiService.ListLogs")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/api/logs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.max != nil {
		localVarQueryParams.Add("max", parameterToString(*r.max, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.order != nil {
		localVarQueryParams.Add("order", parameterToString(*r.order, ""))
	}
	if r.query != nil {
		localVarQueryParams.Add("query", parameterToString(*r.query, ""))
	}
	if r.message != nil {
		localVarQueryParams.Add("message", parameterToString(*r.message, ""))
	}
	if r.sourceType != nil {
		localVarQueryParams.Add("sourceType", parameterToString(*r.sourceType, ""))
	}
	if r.typeCode != nil {
		localVarQueryParams.Add("typeCode", parameterToString(*r.typeCode, ""))
	}
	if r.objectId != nil {
		localVarQueryParams.Add("objectId", parameterToString(*r.objectId, ""))
	}
	if r.token != nil {
		localVarQueryParams.Add("token", parameterToString(*r.token, ""))
	}
	if r.level != nil {
		localVarQueryParams.Add("level", parameterToString(*r.level, ""))
	}
	if r.startMs != nil {
		localVarQueryParams.Add("startMs", parameterToString(*r.startMs, ""))
	}
	if r.endMs != nil {
		localVarQueryParams.Add("endMs", parameterToString(*r.endMs, ""))
	}
	if r.startDateTime != nil {
		localVarQueryParams.Add("startDateTime", parameterToString(*r.startDateTime, ""))
	}
	if r.endDateTime != nil {
		localVarQueryParams.Add("endDateTime", parameterToString(*r.endDateTime, ""))
	}
	if r.containers != nil {
		localVarQueryParams.Add("containers", parameterToString(*r.containers, ""))
	}
	if r.servers != nil {
		localVarQueryParams.Add("servers", parameterToString(*r.servers, ""))
	}
	if r.clusterId != nil {
		localVarQueryParams.Add("clusterId", parameterToString(*r.clusterId, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v DefaultError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}
